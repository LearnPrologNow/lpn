
<!--l. 21--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse14"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=#taillpn-htmlse9"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlch4"> up 
</a> ] 
</p> 
</div> 
<h3 class="sectionHead"> 
<span class="titlemark"> 3.1 
</span> 
<a id="x22-310003.1"> 
</a> Recursive Definitions 
</h3> 
<!--l. 25--> 
<p class="noindent"> Predicates can be defined recursively. Roughly speaking, a predicate is recursively defined if one or more rules in its definition refers to itself. 
</p> 
<!--l. 29--> 
<p class="noindent"> 
</p> 
<h4 class="likesubsectionHead"> 
<a id="x22-320003.1"> 
</a> Example 1: Eating 
</h4> 
<!--l. 33--> 
<p class="noindent"> Consider the following knowledge base: 
</p> 
<div class="fancyvrb" id="fancyvrb112"> 
<a id="x22-32002r1"> 
</a> 
<span class="cmtt-10"> is_digesting(X,Y) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;just_ate(X,Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-32004r2"> 
</a> 
<span class="cmtt-10"> is_digesting(X,Y) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<br class="fancyvrb" /> 
<a id="x22-32006r3"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;just_ate(X,Z), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-32008r4"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;is_digesting(Z,Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-32010r5"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-32012r6"> 
</a> 
<span class="cmtt-10"> just_ate(mosquito,blood(john)). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-32014r7"> 
</a> 
<span class="cmtt-10"> just_ate(frog,mosquito). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-32016r8"> 
</a> 
<span class="cmtt-10"> just_ate(stork,frog). 
</span> 
</div> 
<!--l. 46--> 
<p class="indent"> At first glance this seems pretty ordinary: it&#8217;s just a knowledge base containing three facts and two rules. But the definition of the 
<span class="verb"> 
<span class="cmtt-10"> is_digesting/2 
</span> 
</span> predicate is recursive. Note that 
<span class="verb"> 
<span class="cmtt-10"> is_digesting/2 
</span> 
</span> is (at least partially) defined in terms of itself, for the 
<span class="verb"> 
<span class="cmtt-10"> is_digesting/2 
</span> 
</span> functor occurs in both the head and body of the second rule. Crucially, however, there is an &#8216;escape&#8217; from this circularity. This is provided by the 
<span class="verb"> 
<span class="cmtt-10"> just_ate/2 
</span> 
</span> predicate, which occurs in the first rule. (Significantly, the body of the first rule makes no mention of 
<span class="verb"> 
<span class="cmtt-10"> is_digesting/2 
</span> 
</span> .) Let&#8217;s now consider both the declarative and procedural meanings of this definition. 
</p> 
<!--l. 57--> 
<p class="indent"> The word &#8220;declarative&#8221; is used to talk about the logical meaning of Prolog knowledge bases. That is, the declarative meaning of a Prolog knowledge base is simply &#8220;what it says&#8221;, or &#8220;what it means, if we read it as a collection of logical statements&#8221;. And the declarative meaning of this recursive definition is fairly straightforward. The first clause (the escape clause, the one that is not recursive, or as we shall usually call it, the base clause), simply says that: 
<span class="cmti-10"> if 
</span> 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> has just eaten 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> , 
<span class="cmti-10"> then 
</span> 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> is now digesting 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> . This is obviously a sensible definition. 
</p> 
<!--l. 67--> 
<p class="indent"> So what about the second clause, the recursive clause? This says that: 
<span class="cmti-10"> if 
</span> 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> has just eaten 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> 
<span class="cmti-10"> and 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> is digesting 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> , 
<span class="cmti-10"> then 
</span> 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> is digesting 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> , too. Again, this is obviously a sensible definition. 
</p> 
<!--l. 73--> 
<p class="indent"> So now we know what this recursive definition says, but what happens when we pose a query that actually needs to use this definition? That is, what does this definition actually do? To use the normal Prolog terminology, what is its procedural meaning? 
</p> 
<!--l. 78--> 
<p class="indent"> This is also reasonably straightforward. The base rule is like all the earlier rules we&#8217;ve seen. That is, if we ask whether 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> is digesting 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> , Prolog can use this rule to ask instead the question: has 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> just eaten 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> ? 
</p> 
<!--l. 83--> 
<p class="indent"> What about the recursive clause? This gives Prolog another strategy for determining whether 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> is digesting 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> : 
<span class="cmti-10"> it can try to find some 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> 
<span class="cmti-10"> such that 
</span> 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> 
<span class="cmti-10"> has just 
</span> 
<span class="cmti-10"> eaten 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> , and 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> 
<span class="cmti-10"> is digesting 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> . That is, this rule lets Prolog break the task apart into two subtasks. Hopefully, doing so will eventually lead to simple problems which can be solved by simply looking up the answers in the knowledge base. The following picture sums up the situation: 
</p> 
<div class="center"> 
<!--l. 94--> 
<p class="noindent"> 
</p> 
<!--l. 95--> 
<p class="noindent"> 
<img src="html/chap3-pspic3.ps.png" alt="*Pic not found*" /> 
</p> 
</div> 
<!--l. 98--> 
<p class="indent"> Let&#8217;s see how this works. If we pose the query: 
</p> 
<div class="fancyvrb" id="fancyvrb113"> 
<a id="x22-32018r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;is_digesting(stork,mosquito). 
</span> 
</div> 
<!--l. 102--> 
<p class="noindent"> then Prolog goes to work as follows. First, it tries to make use of the first rule listed concerning 
<span class="verb"> 
<span class="cmtt-10"> is_digesting 
</span> 
</span> ; that is, the base rule. This tells it that 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> is digesting 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> if 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> just ate 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> , By unifying 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> with 
<span class="verb"> 
<span class="cmtt-10"> stork 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> with 
<span class="verb"> 
<span class="cmtt-10"> mosquito 
</span> 
</span> it obtains the following goal: 
</p> 
<div class="fancyvrb" id="fancyvrb114"> 
<a id="x22-32020r1"> 
</a> 
<span class="cmtt-10"> just_ate(stork,mosquito). 
</span> 
</div> 
<!--l. 113--> 
<p class="indent"> But the knowledge base doesn&#8217;t contain the information that the stork just ate the mosquito, so this attempt fails. So Prolog next tries to make use of the second rule. By unifying 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> with 
<span class="verb"> 
<span class="cmtt-10"> stork 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> with 
<span class="verb"> 
<span class="cmtt-10"> mosquito 
</span> 
</span> it obtains the following goals: 
</p> 
<div class="fancyvrb" id="fancyvrb115"> 
<a id="x22-32022r1"> 
</a> 
<span class="cmtt-10"> just_ate(stork,Z), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-32024r2"> 
</a> 
<span class="cmtt-10"> is_digesting(Z,mosquito). 
</span> 
</div> 
<!--l. 122--> 
<p class="noindent"> That is, to show 
<span class="verb"> 
<span class="cmtt-10"> is_digesting(stork,mosquito) 
</span> 
</span> , Prolog needs to find a value for 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> such that, firstly, 
</p> 
<div class="fancyvrb" id="fancyvrb116"> 
<a id="x22-32026r1"> 
</a> 
<span class="cmtt-10"> just_ate(stork,Z). 
</span> 
</div> 
<!--l. 128--> 
<p class="noindent"> and secondly, 
</p> 
<div class="fancyvrb" id="fancyvrb117"> 
<a id="x22-32028r1"> 
</a> 
<span class="cmtt-10"> is_digesting(Z,mosquito). 
</span> 
</div> 
<!--l. 132--> 
<p class="noindent"> And there 
<span class="cmti-10"> is 
</span> such a value for 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> , namely 
<span class="verb"> 
<span class="cmtt-10"> frog 
</span> 
</span> . It is immediate that 
</p> 
<div class="fancyvrb" id="fancyvrb118"> 
<a id="x22-32030r1"> 
</a> 
<span class="cmtt-10"> just_ate(stork,frog). 
</span> 
</div> 
<!--l. 137--> 
<p class="noindent"> will succeed, for this fact is listed in the knowledge base. And deducing 
</p> 
<div class="fancyvrb" id="fancyvrb119"> 
<a id="x22-32032r1"> 
</a> 
<span class="cmtt-10"> is_digesting(frog,mosquito). 
</span> 
</div> 
<!--l. 141--> 
<p class="noindent"> is almost as simple, for the first clause of 
<span class="verb"> 
<span class="cmtt-10"> is_digesting/2 
</span> 
</span> reduces this goal to deducing 
</p> 
<div class="fancyvrb" id="fancyvrb120"> 
<a id="x22-32034r1"> 
</a> 
<span class="cmtt-10"> just_ate(frog,mosquito). 
</span> 
</div> 
<!--l. 146--> 
<p class="noindent"> and this is a fact listed in the knowledge base. 
</p> 
<!--l. 148--> 
<p class="indent"> Well, that&#8217;s our first example of a recursive rule definition. We&#8217;re going to learn a lot more about them, but one very practical remark should be made right away. Hopefully it&#8217;s clear that when you write a recursive predicate, it should always have at least two clauses: a base clause (the clause that stops the recursion at some point), and one that contains the recursion. If you don&#8217;t do this, Prolog can spiral off into an unending sequence of useless computations. For example, here&#8217;s an extremely simple example of a recursive rule definition: 
</p> 
<div class="fancyvrb" id="fancyvrb121"> 
<a id="x22-32036r1"> 
</a> 
<span class="cmtt-10"> p 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;p. 
</span> 
</div> 
<!--l. 160--> 
<p class="noindent"> That&#8217;s it. Nothing else. It&#8217;s beautiful in its simplicity. And from a declarative perspective it&#8217;s an extremely sensible (if rather boring) definition: it says &#8220;if property p holds, then property p holds&#8221;. You can&#8217;t argue with that. 
</p> 
<!--l. 165--> 
<p class="indent"> But from a procedural perspective, this is a wildly dangerous rule. In fact, we have here the ultimate in dangerous recursive rules: exactly the same thing on both sides, and no base clause to let us escape. For consider what happens when we pose the following query: 
</p> 
<div class="fancyvrb" id="fancyvrb122"> 
<a id="x22-32038r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;p. 
</span> 
</div> 
<!--l. 172--> 
<p class="noindent"> Prolog asks itself: &#8220;How do I prove 
<span class="verb"> 
<span class="cmtt-10"> p 
</span> 
</span> ?&#8221; and it realises, &#8220;Hey, I&#8217;ve got a rule for that! To prove 
<span class="verb"> 
<span class="cmtt-10"> p 
</span> 
</span> I just need to prove 
<span class="verb"> 
<span class="cmtt-10"> p 
</span> 
</span> !&#8221;. So it asks itself (again): &#8220;How do I prove 
<span class="verb"> 
<span class="cmtt-10"> p 
</span> 
</span> ?&#8221; and it realises, &#8220;Hey, I&#8217;ve got a rule for that! To prove 
<span class="verb"> 
<span class="cmtt-10"> p 
</span> 
</span> I just need to prove 
<span class="verb"> 
<span class="cmtt-10"> p 
</span> 
</span> !&#8221;. So it asks itself (yet again): &#8220;How do I prove 
<span class="verb"> 
<span class="cmtt-10"> p 
</span> 
</span> ?&#8221; and it realises, &#8220;Hey, I&#8217;ve got a rule for that! To prove 
<span class="verb"> 
<span class="cmtt-10"> p 
</span> 
</span> I just need to prove 
<span class="verb"> 
<span class="cmtt-10"> p 
</span> 
</span> !&#8221; and so on and so forth. 
</p> 
<!--l. 180--> 
<p class="indent"> If you make this query, Prolog won&#8217;t answer you: it will head off, looping desperately away in an unending search. That is, it won&#8217;t terminate, and you&#8217;ll have to interrupt it. Of course, if you use 
<span class="verb"> 
<span class="cmtt-10"> trace 
</span> 
</span> , you can step through one step at a time, until you get sick of watching Prolog loop. 
</p> 
<!--l. 186--> 
<p class="noindent"> 
</p> 
<h4 class="likesubsectionHead"> 
<a id="x22-330003.1"> 
</a> Example 2: Descendant 
</h4> 
<!--l. 190--> 
<p class="noindent"> Now that we know something about 
<span class="cmti-10"> what 
</span> recursion in Prolog involves, it is time to ask 
<span class="cmti-10"> why 
</span> it is so important. Actually, this is a question that can be answered on a number of levels, but for now, let&#8217;s keep things fairly practical. So: when it comes to writing useful Prolog programs, are recursive definitions really so important? And if so, why? 
</p> 
<!--l. 197--> 
<p class="indent"> Let&#8217;s consider an example. Suppose we have a knowledge base recording facts about the child relation: 
</p> 
<div class="fancyvrb" id="fancyvrb123"> 
<a id="x22-33002r1"> 
</a> 
<span class="cmtt-10"> child(bridget,caroline). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33004r2"> 
</a> 
<span class="cmtt-10"> child(caroline,donna). 
</span> 
</div> 
<!--l. 203--> 
<p class="noindent"> That is, Caroline is a child of Bridget, and Donna is a child of Caroline. Now suppose we wished to define the descendant relation; that is, the relation of being a child of, or a child of a child of, or a child of a child of a child of, and so on. Here&#8217;s a first attempt to do this. We could add the following two 
<span class="cmti-10"> non 
</span> -recursive rules to the knowledge base: 
</p> 
<div class="fancyvrb" id="fancyvrb124"> 
<a id="x22-33006r1"> 
</a> 
<span class="cmtt-10"> descend(X,Y) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;child(X,Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33008r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-33010r3"> 
</a> 
<span class="cmtt-10"> descend(X,Y) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;child(X,Z), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33012r4"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z,Y). 
</span> 
</div> 
<!--l. 217--> 
<p class="indent"> Now, fairly obviously these definitions work up to a point, but they are clearly limited: they only define the concept of descendant-of for two generations or less. That&#8217;s ok for the above knowledge base, but suppose we get some more information about the child-of relation and we expand our list of child-of facts to this: 
</p> 
<div class="fancyvrb" id="fancyvrb125"> 
<a id="x22-33014r1"> 
</a> 
<span class="cmtt-10"> child(anne,bridget). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33016r2"> 
</a> 
<span class="cmtt-10"> child(bridget,caroline). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33018r3"> 
</a> 
<span class="cmtt-10"> child(caroline,donna). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33020r4"> 
</a> 
<span class="cmtt-10"> child(donna,emily). 
</span> 
</div> 
<!--l. 229--> 
<p class="indent"> Now our two rules are inadequate. For example, if we pose the queries 
</p> 
<div class="fancyvrb" id="fancyvrb126"> 
<a id="x22-33022r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;descend(anne,donna). 
</span> 
</div> 
<!--l. 233--> 
<p class="noindent"> or 
</p> 
<div class="fancyvrb" id="fancyvrb127"> 
<a id="x22-33024r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;descend(bridget,emily). 
</span> 
</div> 
<!--l. 237--> 
<p class="noindent"> we get the answer no, which is 
<span class="cmti-10"> not 
</span> what we want. Sure, we could &#8216;fix&#8217; this by adding the following two rules: 
</p> 
<div class="fancyvrb" id="fancyvrb128"> 
<a id="x22-33026r1"> 
</a> 
<span class="cmtt-10"> descend(X,Y) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;child(X,Z_1), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33028r2"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z_1,Z_2), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33030r3"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z_2,Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33032r4"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-33034r5"> 
</a> 
<span class="cmtt-10"> descend(X,Y) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;child(X,Z_1), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33036r6"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z_1,Z_2), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33038r7"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z_2,Z_3), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33040r8"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z_3,Y). 
</span> 
</div> 
<!--l. 250--> 
<p class="indent"> But, let&#8217;s face it, this is clumsy and hard to read. Moreover, if we add further child-of facts, we could easily find ourselves having to add more and more rules as our list of child-of facts grow, rules like: 
</p> 
<div class="fancyvrb" id="fancyvrb129"> 
<a id="x22-33042r1"> 
</a> 
<span class="cmtt-10"> descend(X,Y) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;child(X,Z_1), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33044r2"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z_1,Z_2), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33046r3"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z_2,Z_3), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33048r4"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;. 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33050r5"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;. 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33052r6"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;. 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33054r7"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z_17,Z_18). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33056r8"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z_18,Z_19). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33058r9"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;child(Z_19,Y). 
</span> 
</div> 
<!--l. 265--> 
<p class="noindent"> This is not a particularly pleasant (or sensible) way to go! 
</p> 
<!--l. 267--> 
<p class="indent"> But we don&#8217;t need to do this at all. We can avoid having to use ever longer rules entirely. The following recursive predicate definition fixes everything exactly the way we want: 
</p> 
<div class="fancyvrb" id="fancyvrb130"> 
<a id="x22-33060r1"> 
</a> 
<span class="cmtt-10"> descend(X,Y) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;child(X,Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33062r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-33064r3"> 
</a> 
<span class="cmtt-10"> descend(X,Y) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;child(X,Z), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33066r4"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;descend(Z,Y). 
</span> 
</div> 
<!--l. 280--> 
<p class="indent"> What does this say? The declarative meaning of the base clause is: 
<span class="cmti-10"> if 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> is a child of 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> , 
<span class="cmti-10"> then 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> is a descendant of 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> . Obviously sensible. So what about the recursive clause? Its declarative meaning is: 
<span class="cmti-10"> if 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> is a child of 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> , 
<span class="cmti-10"> and 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> is a descendant of 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> , 
<span class="cmti-10"> then 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> is a descendant of 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> . Again, this is obviously true. 
</p> 
<!--l. 288--> 
<p class="indent"> So let&#8217;s now look at the procedural meaning of this recursive predicate, by stepping through an example. What happens when we pose the query: 
</p> 
<div class="fancyvrb" id="fancyvrb131"> 
<a id="x22-33068r1"> 
</a> 
<span class="cmtt-10"> descend(anne,donna) 
</span> 
</div> 
<!--l. 294--> 
<p class="noindent"> Prolog first tries the first rule. The variable 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> in the head of the rule is unified with 
<span class="verb"> 
<span class="cmtt-10"> anne 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> with 
<span class="verb"> 
<span class="cmtt-10"> donna 
</span> 
</span> and the next goal Prolog tries to prove is 
</p> 
<!--l. 298--> 
<p class="indent"> 
</p> 
<div class="fancyvrb" id="fancyvrb132"> 
<a id="x22-33070r1"> 
</a> 
<span class="cmtt-10"> child(anne,donna) 
</span> 
</div> 
<!--l. 303--> 
<p class="indent"> This attempt fails, however, since the knowledge base neither contains the fact 
<span class="verb"> 
<span class="cmtt-10"> child(anne,donna) 
</span> 
</span> nor any rules that would allow to infer it. So Prolog backtracks and looks for an alternative way of proving 
<span class="verb"> 
<span class="cmtt-10"> descend(anne,donna) 
</span> 
</span> . It finds the second rule in the knowledge base and now has the following subgoals: 
</p> 
<!--l. 310--> 
<p class="indent"> 
</p> 
<div class="fancyvrb" id="fancyvrb133"> 
<a id="x22-33072r1"> 
</a> 
<span class="cmtt-10"> child(anne,_633), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33074r2"> 
</a> 
<span class="cmtt-10"> descend(_633,donna). 
</span> 
</div> 
<!--l. 316--> 
<p class="indent"> Prolog takes the first subgoal and tries to unify it with something in the knowledge base. It finds the fact 
<span class="verb"> 
<span class="cmtt-10"> child(anne,bridget) 
</span> 
</span> and the variable 
<span class="verb"> 
<span class="cmtt-10"> _633 
</span> 
</span> gets instantiated to 
<span class="verb"> 
<span class="cmtt-10"> bridget 
</span> 
</span> . Now that the first subgoal is satisfied, Prolog moves to the second subgoal. It has to prove 
</p> 
<!--l. 322--> 
<p class="indent"> 
</p> 
<div class="fancyvrb" id="fancyvrb134"> 
<a id="x22-33076r1"> 
</a> 
<span class="cmtt-10"> descend(bridget,donna) 
</span> 
</div> 
<!--l. 327--> 
<p class="indent"> This is the first recursive call of the predicate 
<span class="verb"> 
<span class="cmtt-10"> descend/2 
</span> 
</span> . As before, Prolog starts with the first rule, but fails, because the goal 
</p> 
<!--l. 330--> 
<p class="indent"> 
</p> 
<div class="fancyvrb" id="fancyvrb135"> 
<a id="x22-33078r1"> 
</a> 
<span class="cmtt-10"> child(bridget,donna) 
</span> 
</div> 
<!--l. 333--> 
<p class="noindent"> cannot be proved. Backtracking, Prolog finds that there is a second possibility to be checked for 
<span class="verb"> 
<span class="cmtt-10"> descend(bridget,donna) 
</span> 
</span> , namely the second rule, which again gives Prolog two new subgoals: 
</p> 
<!--l. 337--> 
<p class="indent"> 
</p> 
<div class="fancyvrb" id="fancyvrb136"> 
<a id="x22-33080r1"> 
</a> 
<span class="cmtt-10"> child(bridget,_1785), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-33082r2"> 
</a> 
<span class="cmtt-10"> descend(_1785,donna). 
</span> 
</div> 
<!--l. 343--> 
<p class="indent"> The first one can be unified with the fact 
<span class="verb"> 
<span class="cmtt-10"> child(bridget,caroline) 
</span> 
</span> of the knowledge base, so that the variable 
<span class="verb"> 
<span class="cmtt-10"> _1785 
</span> 
</span> is instantiated with 
<span class="verb"> 
<span class="cmtt-10"> caroline 
</span> 
</span> . Next Prolog tries to prove 
</p> 
<!--l. 348--> 
<p class="indent"> 
</p> 
<div class="fancyvrb" id="fancyvrb137"> 
<a id="x22-33084r1"> 
</a> 
<span class="cmtt-10"> descend(caroline,donna). 
</span> 
</div> 
<!--l. 351--> 
<p class="noindent"> This is the second recursive call of predicate 
<span class="verb"> 
<span class="cmtt-10"> descend/2 
</span> 
</span> . As before, it tries the first rule first, obtaining the following new goal: 
</p> 
<!--l. 355--> 
<p class="indent"> 
</p> 
<div class="fancyvrb" id="fancyvrb138"> 
<a id="x22-33086r1"> 
</a> 
<span class="cmtt-10"> child(caroline,donna) 
</span> 
</div> 
<!--l. 360--> 
<p class="indent"> This time Prolog succeeds, since 
<span class="verb"> 
<span class="cmtt-10"> child(caroline,donna) 
</span> 
</span> is a fact in the database. Prolog has found a proof for the goal 
<span class="verb"> 
<span class="cmtt-10"> descend(caroline,donna) 
</span> 
</span> (the second recursive call). But this means that 
<span class="verb"> 
<span class="cmtt-10"> descend(bridget,donna) 
</span> 
</span> (the first recursive call) is also true, which means that our original query 
<span class="verb"> 
<span class="cmtt-10"> descend(anne,donna) 
</span> 
</span> is true as well. 
</p> 
<!--l. 367--> 
<p class="indent"> Here is the search tree for the query 
<span class="verb"> 
<span class="cmtt-10"> descend(anne,donna) 
</span> 
</span> . Make sure that you understand how it relates to the discussion in the text; that is, how Prolog traverses this search tree when trying to prove this query. 
</p> 
<div class="center"> 
<!--l. 372--> 
<p class="noindent"> 
</p> 
<!--l. 373--> 
<p class="noindent"> 
<img src="html/chap3-pspic1.ps.png" alt="*Pic not found*" /> 
</p> 
</div> 
<!--l. 381--> 
<p class="indent"> It should be obvious from this example that no matter how many generations of children we add, we will always be able to work out the descendant relation. That is, the recursive definition is both general and compact: it contains 
<span class="cmti-10"> all 
</span> the information in the non-recursive rules, and much more besides. The non-recursive rules only defined the descendant concept up to some fixed number of generations: we would need to write down infinitely many non-recursive rules if we wanted to capture this concept fully, and of course that&#8217;s impossible. But, in effect, that&#8217;s what the recursive rule does for us: it bundles up the information needed to cope with arbitrary numbers of generations into just three lines of code. 
</p> 
<!--l. 393--> 
<p class="indent"> Recursive rules are really important. They enable to pack an enormous amount of information into a compact form and to define predicates in a natural way. Most of the work you will do as a Prolog programmer will involve writing recursive rules. 
</p> 
<!--l. 398--> 
<p class="noindent"> 
</p> 
<h4 class="likesubsectionHead"> 
<a id="x22-340003.1"> 
</a> Example 3: Successor 
</h4> 
<!--l. 402--> 
<p class="noindent"> In the previous chapter we remarked that building structure through unification is a key idea in Prolog programming. Now that we know about recursion, we can give more interesting illustrations of this. 
</p> 
<!--l. 406--> 
<p class="indent"> Nowadays, when human beings write numerals, they usually use 
<span class="cmti-10"> decimal 
</span> notation (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, and so on) but as you probably know, there are many other notations. For example, because computer hardware is generally based on digital circuits, computers usually use 
<span class="cmti-10"> binary 
</span> notation to represent numerals (0, 1, 10, 11, 100, 101, 110, 111, 1000, and so on), for the 0 can be implemented as a switch being off, the 1 as a switch being on. Other cultures use different systems. For example, the ancient Babylonians used a base 60 system, while the ancient Romans used a rather ad-hoc system (I, II, III, IV, V, VI, VII, VIII, IX, X). This last example shows that notational issues can be important. If you don&#8217;t believe this, try figuring out a systematic way of doing long-division in Roman notation. As you&#8217;ll discover, it&#8217;s a frustrating task. Apparently the Romans had a group of professionals (analogs of modern accountants) who specialised in this. 
</p> 
<!--l. 422--> 
<p class="indent"> Well, here&#8217;s yet another way of writing numerals, which is sometimes used in mathematical logic. It makes use of just four symbols: 0, 
<span class="cmti-10"> succ 
</span> , and the left and right parentheses. This style of numeral is defined by the following inductive definition: 
</p> 
<ol class="enumerate1"> 
<li class="enumerate" id="x22-34002x1"> 0 is a numeral. 
</li> 
<li class="enumerate" id="x22-34004x2"> If 
<span class="cmti-10"> X 
</span> is a numeral, then so is 
<span class="cmti-10"> succ(X) 
</span> . 
</li> 
</ol> 
<!--l. 433--> 
<p class="indent"> As is probably clear, 
<span class="cmti-10"> succ 
</span> can be read as short for 
<span class="cmti-10"> successor 
</span> . That is, 
<span class="cmti-10"> succ(X) 
</span> represents the number obtained by adding one to the number represented by 
<span class="cmti-10"> X 
</span> . So this is a very simple notation: it simply says that 0 is a numeral, and that all other numerals are built by stacking 
<span class="cmti-10"> succ 
</span> symbols in front. (In fact, it&#8217;s used in mathematical logic because of this simplicity. Although it wouldn&#8217;t be pleasant to do household accounts in this notation, it is a very easy notation to prove things 
<span class="cmti-10"> about 
</span> .) 
</p> 
<!--l. 442--> 
<p class="indent"> Now, by this stage it should be clear that we can turn this definition into a Prolog program. The following knowledge base does this: 
</p> 
<div class="fancyvrb" id="fancyvrb139"> 
<a id="x22-34006r1"> 
</a> 
<span class="cmtt-10"> numeral(0). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-34008r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-34010r3"> 
</a> 
<span class="cmtt-10"> numeral(succ(X)) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;numeral(X). 
</span> 
</div> 
<!--l. 450--> 
<p class="noindent"> So if we pose queries like 
</p> 
<div class="fancyvrb" id="fancyvrb140"> 
<a id="x22-34012r1"> 
</a> 
<span class="cmtt-10"> numeral(succ(succ(succ(0)))). 
</span> 
</div> 
<!--l. 454--> 
<p class="noindent"> we get the answer yes. 
</p> 
<!--l. 456--> 
<p class="indent"> But we can do some more interesting things. Consider what happens when we pose the following query: 
</p> 
<div class="fancyvrb" id="fancyvrb141"> 
<a id="x22-34014r1"> 
</a> 
<span class="cmtt-10"> numeral(X). 
</span> 
</div> 
<!--l. 461--> 
<p class="noindent"> That is, we&#8217;re saying &#8220;Ok, show me some numerals&#8221;. Then we can have the following dialogue with Prolog: 
</p> 
<div class="fancyvrb" id="fancyvrb142"> 
<a id="x22-34016r1"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;0 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x22-34018r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-34020r3"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;succ(0) 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x22-34022r4"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-34024r5"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)) 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x22-34026r6"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-34028r7"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(0))) 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x22-34030r8"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-34032r9"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(succ(0)))) 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x22-34034r10"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-34036r11"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(succ(succ(0))))) 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x22-34038r12"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-34040r13"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(succ(succ(succ(0)))))) 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x22-34042r14"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-34044r15"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(succ(succ(succ(succ(0))))))) 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x22-34046r16"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-34048r17"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(succ(succ(succ(succ(succ(0)))))))) 
</span> 
<br class="fancyvrb" /> 
<a id="x22-34050r18"> 
</a> 
<span class="cmtt-10"> yes 
</span> 
</div> 
<!--l. 485--> 
<p class="indent"> Yes, Prolog is counting: but what&#8217;s really important is 
<span class="cmti-10"> how 
</span> it&#8217;s doing this. Quite simply, it&#8217;s backtracking through the recursive definition, and actually 
<span class="cmti-10"> building 
</span> numerals using unification. This is an instructive example, and it is important that you understand it. The best way to do so is to sit down and try it out, with 
<span class="verb"> 
<span class="cmtt-10"> trace 
</span> 
</span> turned on. 
</p> 
<!--l. 492--> 
<p class="indent"> Building and binding. Recursion, unification, and proof search. These are ideas that lie at the heart of Prolog programming. Whenever we have to generate or analyse recursively structured objects (such as these numerals) the interplay of these ideas makes Prolog a powerful tool. For example, in the next chapter we shall introduce lists, an extremely important recursive data structure, and we will see that Prolog is a natural list processing language. Many applications (computational linguistics is a prime example) make heavy use of recursively structured objects, such as trees and feature structures. So it&#8217;s not particularly surprising that Prolog has proved useful in such applications. 
</p> 
<!--l. 504--> 
<p class="noindent"> 
</p> 
<h4 class="likesubsectionHead"> 
<a id="x22-350003.1"> 
</a> Example 4: Addition 
</h4> 
<!--l. 508--> 
<p class="noindent"> As a final example, let&#8217;s see whether we can use the representation of numerals that we introduced in the previous section for doing simple arithmetic. Let&#8217;s try to define addition. That is, we want to define a predicate 
<span class="verb"> 
<span class="cmtt-10"> add/3 
</span> 
</span> which when given two numerals as the first and second argument returns the result of adding them up as its third argument. For example: 
</p> 
<div class="fancyvrb" id="fancyvrb143"> 
<a id="x22-35002r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;add(succ(succ(0)),succ(succ(0)), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35004r2"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(succ(0))))). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35006r3"> 
</a> 
<span class="cmtt-10"> yes 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35008r4"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;add(succ(succ(0)),succ(0),Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35010r5"> 
</a> 
<span class="cmtt-10"> Y 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(0))) 
</span> 
</div> 
<!--l. 522--> 
<p class="indent"> There are two things which are important to notice: 
</p> 
<ol class="enumerate1"> 
<li class="enumerate" id="x22-35012x1"> Whenever the first argument is 
<span class="verb"> 
<span class="cmtt-10"> 0 
</span> 
</span> , the third argument has to be the same as the second argument: 
<div class="fancyvrb" id="fancyvrb144"> 
<a id="x22-35014r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;add(0,succ(succ(0)),Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35016r2"> 
</a> 
<span class="cmtt-10"> Y 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)) 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35018r3"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;add(0,0,Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35020r4"> 
</a> 
<span class="cmtt-10"> Y 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;0 
</span> 
</div> 
<!--l. 533--> 
<p class="noindent"> This is the case that we want to use for the base clause. 
</p> 
</li> 
<li class="enumerate" id="x22-35022x2"> Assume that we want to add the two numerals 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> (for example 
<span class="verb"> 
<span class="cmtt-10"> succ(succ(succ(0))) 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> succ(succ(0)) 
</span> 
</span> ) and that 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> is not 
<span class="verb"> 
<span class="cmtt-10"> 0 
</span> 
</span> . Now, if 
<span class="verb"> 
<span class="cmtt-10"> X1 
</span> 
</span> is the numeral that has one 
<span class="verb"> 
<span class="cmtt-10"> succ 
</span> 
</span> functor less than 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> (that is, 
<span class="verb"> 
<span class="cmtt-10"> succ(succ(0)) 
</span> 
</span> in our example) and if we know the result &#8211; let&#8217;s call it 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> &#8211; of adding 
<span class="verb"> 
<span class="cmtt-10"> X1 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> (namely 
<span class="verb"> 
<span class="cmtt-10"> succ(succ(succ(succ(0)))) 
</span> 
</span> ), then it is very easy to compute the result of adding 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> : we just have to add one 
<span class="verb"> 
<span class="cmtt-10"> succ 
</span> 
</span> -functor to 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> . This is what we want to express with the recursive clause. 
</li> 
</ol> 
<!--l. 546--> 
<p class="indent"> Here is the predicate definition that expresses exactly what we just said: 
</p> 
<div class="fancyvrb" id="fancyvrb145"> 
<a id="x22-35024r1"> 
</a> 
<span class="cmtt-10"> add(0,Y,Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35026r2"> 
</a> 
<span class="cmtt-10"> add(succ(X),Y,succ(Z)) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35028r3"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;add(X,Y,Z). 
</span> 
</div> 
<!--l. 553--> 
<p class="indent"> So what happens, if we give Prolog this predicate definition and then ask: 
</p> 
<div class="fancyvrb" id="fancyvrb146"> 
<a id="x22-35030r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;add(succ(succ(succ(0))), 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)), 
</span> 
<span class="cmtt-10"> &#x00A0;R). 
</span> 
</div> 
<!--l. 558--> 
<p class="noindent"> Let&#8217;s go step by step through the way Prolog processes this query. The trace and search tree for the query are given below. 
</p> 
<!--l. 561--> 
<p class="indent"> The first argument is not 
<span class="verb"> 
<span class="cmtt-10"> 0 
</span> 
</span> , which means that only the second clause for 
<span class="verb"> 
<span class="cmtt-10"> add/3 
</span> 
</span> can be used. This leads to a recursive call of 
<span class="verb"> 
<span class="cmtt-10"> add/3 
</span> 
</span> . The outermost 
<span class="verb"> 
<span class="cmtt-10"> succ 
</span> 
</span> functor is stripped off the first argument of the original query, and the result becomes the first argument of the recursive query. The second argument is passed on unchanged to the recursive query, and the third argument of the recursive query is a variable, the internal variable 
<span class="verb"> 
<span class="cmtt-10"> _G648 
</span> 
</span> in the trace given below. Note that 
<span class="verb"> 
<span class="cmtt-10"> _G648 
</span> 
</span> is not instantiated yet. However it shares values with 
<span class="verb"> 
<span class="cmtt-10"> R 
</span> 
</span> (the variable that we used as the third argument in the original query) because 
<span class="verb"> 
<span class="cmtt-10"> R 
</span> 
</span> was instantiated to 
<span class="verb"> 
<span class="cmtt-10"> succ(_G648) 
</span> 
</span> when the query was unified with the head of the second clause. But that means that 
<span class="verb"> 
<span class="cmtt-10"> R 
</span> 
</span> is not a completely uninstantiated variable anymore. It is now a complex term, that has a (uninstantiated) variable as its argument. 
</p> 
<!--l. 575--> 
<p class="indent"> The next two steps are essentially the same. With every step the first argument becomes one layer of 
<span class="verb"> 
<span class="cmtt-10"> succ 
</span> 
</span> smaller; both the trace and the search tree given below show this nicely. At the same time, a 
<span class="verb"> 
<span class="cmtt-10"> succ 
</span> 
</span> functor is added to 
<span class="verb"> 
<span class="cmtt-10"> R 
</span> 
</span> at every step, but always leaving the innermost variable uninstantiated. After the first recursive call 
<span class="verb"> 
<span class="cmtt-10"> R 
</span> 
</span> is 
<span class="verb"> 
<span class="cmtt-10"> succ(_G648) 
</span> 
</span> . After the second recursive call, 
<span class="verb"> 
<span class="cmtt-10"> _G648 
</span> 
</span> is instantiated with 
<span class="verb"> 
<span class="cmtt-10"> succ(_G650) 
</span> 
</span> , so that 
<span class="verb"> 
<span class="cmtt-10"> R 
</span> 
</span> is 
<span class="verb"> 
<span class="cmtt-10"> succ(succ(_G650) 
</span> 
</span> . After the third recursive call, 
<span class="verb"> 
<span class="cmtt-10"> _G650 
</span> 
</span> is instantiated with 
<span class="verb"> 
<span class="cmtt-10"> succ(_G652) 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> R 
</span> 
</span> therefore becomes 
<span class="verb"> 
<span class="cmtt-10"> succ(succ(succ(_G652))) 
</span> 
</span> . The search tree shows this step by step instantiation. 
</p> 
<!--l. 586--> 
<p class="indent"> At this stage all 
<span class="verb"> 
<span class="cmtt-10"> succ 
</span> 
</span> functors have been stripped off the first argument and we can apply the base clause. The third argument is equated with the second argument, so the &#8216;hole&#8217; (the uninstantiated variable) in the complex term 
<span class="verb"> 
<span class="cmtt-10"> R 
</span> 
</span> is finally filled, and we are through. 
</p> 
<!--l. 592--> 
<p class="indent"> Here&#8217;s the complete trace of our query: 
</p> 
<div class="fancyvrb" id="fancyvrb147"> 
<a id="x22-35032r1"> 
</a> 
<span class="cmtt-10"> Call: 
</span> 
<span class="cmtt-10"> &#x00A0;(6) 
</span> 
<span class="cmtt-10"> &#x00A0;add(succ(succ(succ(0))), 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)), 
</span> 
<span class="cmtt-10"> &#x00A0;R) 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35034r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-35036r3"> 
</a> 
<span class="cmtt-10"> Call: 
</span> 
<span class="cmtt-10"> &#x00A0;(7) 
</span> 
<span class="cmtt-10"> &#x00A0;add(succ(succ(0)), 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)), 
</span> 
<span class="cmtt-10"> &#x00A0;_G648) 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35038r4"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-35040r5"> 
</a> 
<span class="cmtt-10"> Call: 
</span> 
<span class="cmtt-10"> &#x00A0;(8) 
</span> 
<span class="cmtt-10"> &#x00A0;add(succ(0), 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)), 
</span> 
<span class="cmtt-10"> &#x00A0;_G650) 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35042r6"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-35044r7"> 
</a> 
<span class="cmtt-10"> Call: 
</span> 
<span class="cmtt-10"> &#x00A0;(9) 
</span> 
<span class="cmtt-10"> &#x00A0;add(0, 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)), 
</span> 
<span class="cmtt-10"> &#x00A0;_G652) 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35046r8"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-35048r9"> 
</a> 
<span class="cmtt-10"> Exit: 
</span> 
<span class="cmtt-10"> &#x00A0;(9) 
</span> 
<span class="cmtt-10"> &#x00A0;add(0, 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)), 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0))) 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35050r10"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-35052r11"> 
</a> 
<span class="cmtt-10"> Exit: 
</span> 
<span class="cmtt-10"> &#x00A0;(8) 
</span> 
<span class="cmtt-10"> &#x00A0;add(succ(0), 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)), 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(0)))) 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35054r12"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-35056r13"> 
</a> 
<span class="cmtt-10"> Exit: 
</span> 
<span class="cmtt-10"> &#x00A0;(7) 
</span> 
<span class="cmtt-10"> &#x00A0;add(succ(succ(0)), 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35058r14"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(succ(0))))) 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35060r15"> 
</a> 
<br class="fancyvrb" /> 
<a id="x22-35062r16"> 
</a> 
<span class="cmtt-10"> Exit: 
</span> 
<span class="cmtt-10"> &#x00A0;(6) 
</span> 
<span class="cmtt-10"> &#x00A0;add(succ(succ(succ(0))), 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(0)), 
</span> 
<br class="fancyvrb" /> 
<a id="x22-35064r17"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;succ(succ(succ(succ(succ(0)))))) 
</span> 
</div> 
<!--l. 613--> 
<p class="indent"> And here&#8217;s the search tree: 
</p> 
<div class="center"> 
<!--l. 615--> 
<p class="noindent"> 
</p> 
<!--l. 616--> 
<p class="noindent"> 
<img src="html/chap3-pspic2.ps.png" alt="*Pic not found*" /> 
</p> 
</div> 
<!--l. 619--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse14"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse9"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlch4"> up 
</a> ] 
</p> 
</div> 
<!--l. 619--> 
<p class="indent"> 
<a id="taillpn-htmlse9"> 
</a> 
</p> 