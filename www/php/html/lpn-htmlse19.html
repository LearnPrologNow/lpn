
<!--l. 120--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse24"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse18"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse18"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse15"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse22"> up 
</a> ] 
</p> 
</div> 
<h3 class="sectionHead"> 
<span class="titlemark"> 5.2 
</span> 
<a id="x34-470005.2"> 
</a> A Closer Look 
</h3> 
<!--l. 122--> 
<p class="noindent"> That&#8217;s the basics, but we need to know more. The most important to grasp is this: +, *, -, 
<span class="cmsy-10"> รท 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> mod 
</span> 
</span> do 
<span class="cmti-10"> not 
</span> carry out any arithmetic. In fact, expressions such as 
<span class="verb"> 
<span class="cmtt-10"> 3+2 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> 3-2 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> 3*2 
</span> 
</span> are simply terms. The functors of these terms are 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> - 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> * 
</span> 
</span> respectively, and the arguments are 
<span class="verb"> 
<span class="cmtt-10"> 3 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> 2 
</span> 
</span> . Apart from the fact that the functors go between their arguments (instead of in front of them) these are ordinary Prolog terms, and unless we do something special, Prolog will not actually do any arithmetic. In particular, if we pose the query 
</p> 
<div class="fancyvrb" id="fancyvrb235"> 
<a id="x34-47002r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;3+2 
</span> 
</div> 
<!--l. 134--> 
<p class="noindent"> we don&#8217;t get back the answer 
<span class="verb"> 
<span class="cmtt-10"> X=5 
</span> 
</span> . Instead we get back 
</p> 
<div class="fancyvrb" id="fancyvrb236"> 
<a id="x34-47004r1"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;3+2 
</span> 
<br class="fancyvrb" /> 
<a id="x34-47006r2"> 
</a> 
<span class="cmtt-10"> yes 
</span> 
</div> 
<!--l. 140--> 
<p class="noindent"> That is, Prolog has simply unified the variable 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> to the complex term 
<span class="verb"> 
<span class="cmtt-10"> 3+2 
</span> 
</span> . It has 
<span class="cmti-10"> not 
</span> carried out any arithmetic. It has simply done what it usually does when 
<span class="cmtt-10"> =/2 
</span> is used: performed unification. 
</p> 
<!--l. 145--> 
<p class="indent"> Similarly, if we pose the query 
</p> 
<div class="fancyvrb" id="fancyvrb237"> 
<a id="x34-47008r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;3+2*5 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;X 
</span> 
</div> 
<!--l. 150--> 
<p class="noindent"> we get the response 
</p> 
<div class="fancyvrb" id="fancyvrb238"> 
<a id="x34-47010r1"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;3+2*5 
</span> 
<br class="fancyvrb" /> 
<a id="x34-47012r2"> 
</a> 
<span class="cmtt-10"> yes 
</span> 
</div> 
<!--l. 155--> 
<p class="noindent"> Again, Prolog has simply bound the variable 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> to the complex term 
<span class="verb"> 
<span class="cmtt-10"> 3+2*5 
</span> 
</span> . It did not evaluate this expression to 13. 
</p> 
<!--l. 158--> 
<p class="indent"> To force Prolog to actually evaluate arithmetic expressions we have to use 
</p> 
<div class="fancyvrb" id="fancyvrb239"> 
<a id="x34-47014r1"> 
</a> 
<span class="cmtt-10"> is 
</span> 
</div> 
<!--l. 163--> 
<p class="noindent"> just as we did in our earlier examples. In fact, 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> does something very special: it sends a signal to Prolog that says &#8220;Hey! Don&#8217;t treat this expression as an ordinary complex term! Call up your built-in arithmetic capabilities and carry out the calculations!&#8221; 
</p> 
<!--l. 168--> 
<p class="indent"> In short, 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> forces Prolog to act in an unusual way. Normally Prolog is quite happy just unifying variables to structures: that&#8217;s its job, after all. Arithmetic is something extra that has been bolted on to the basic Prolog engine because it is useful. Unsurprisingly, there are some restrictions on this extra ability, and we need to know what they are. 
</p> 
<!--l. 175--> 
<p class="indent"> For a start, the arithmetic expressions to be evaluated must be on the right hand side of 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> . In our earlier examples we carefully posed the query 
</p> 
<div class="fancyvrb" id="fancyvrb240"> 
<a id="x34-47016r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;X 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;6+2. 
</span> 
<br class="fancyvrb" /> 
<a id="x34-47018r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x34-47020r3"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;8 
</span> 
</div> 
<!--l. 183--> 
<p class="noindent"> which is the right way to do it. If instead we had asked 
</p> 
<div class="fancyvrb" id="fancyvrb241"> 
<a id="x34-47022r1"> 
</a> 
<span class="cmtt-10"> 6+2 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;X. 
</span> 
</div> 
<!--l. 188--> 
<p class="noindent"> we would have got a message saying 
<span class="verb"> 
<span class="cmtt-10"> instantiation_error 
</span> 
</span> , or something similar. 
</p> 
<!--l. 191--> 
<p class="indent"> Moreover, although we are free to use variables on the right hand side of 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> , when we actually carry out evaluation, the variable must already have been instantiated to a variable-free arithmetic expression. If the variable is uninstantiated, or if it is instantiated to something other than an integer, we will get some sort of 
<span class="verb"> 
<span class="cmtt-10"> instantiation_error 
</span> 
</span> message. This is because arithmetic isn&#8217;t performed using Prolog&#8217;s usual unification and knowledge base search mechanisms: it&#8217;s done by calling up a special black box which knows about integer arithmetic. If we hand the black box the wrong kind of data, it&#8217;s going to complain. 
</p> 
<!--l. 202--> 
<p class="indent"> Here&#8217;s an example. Recall our &#8220;add 3 and double it&#8221; predicate. 
</p> 
<div class="fancyvrb" id="fancyvrb242"> 
<a id="x34-47024r1"> 
</a> 
<span class="cmtt-10"> add_3_and_double(X,Y) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;Y 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;(X+3)*2. 
</span> 
</div> 
<!--l. 207--> 
<p class="noindent"> When we described this predicate, we carefully said that it added 3 to its first argument, doubled the result, and returned the answer in its second argument. For example, 
<span class="verb"> 
<span class="cmtt-10"> add_3_and_double(3,X) 
</span> 
</span> returns 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;12 
</span> 
</span> . We didn&#8217;t say anything about using this predicate in the reverse direction. For example, we might hope that posing the query 
</p> 
<div class="fancyvrb" id="fancyvrb243"> 
<a id="x34-47026r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;add_3_and_double(X,12). 
</span> 
</div> 
<!--l. 216--> 
<p class="noindent"> would return the answer 
<span class="verb"> 
<span class="cmtt-10"> X=3 
</span> 
</span> . But it doesn&#8217;t. Instead we get the 
<span class="verb"> 
<span class="cmtt-10"> instantiation_error 
</span> 
</span> message. Why? Well, when we pose the query this way round, we are asking Prolog to evaluate 
<span class="verb"> 
<span class="cmtt-10"> 12 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;(X+3)*2 
</span> 
</span> , which it 
<span class="cmti-10"> can&#8217;t 
</span> do as 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> is not instantiated. 
</p> 
<!--l. 222--> 
<p class="indent"> Two final remarks. As we&#8217;ve already mentioned, for Prolog 
<span class="verb"> 
<span class="cmtt-10"> 3 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;2 
</span> 
</span> is just a term. In fact, for Prolog, it really 
<span class="cmti-10"> is 
</span> the term 
<span class="cmti-10"> +(3,2) 
</span> . The expression 
<span class="verb"> 
<span class="cmtt-10"> 3 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;2 
</span> 
</span> is just a user-friendly notation that&#8217;s nicer for us to use. This means that, if you want to, you can give Prolog queries like 
</p> 
<div class="fancyvrb" id="fancyvrb244"> 
<a id="x34-47028r1"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;+(3,2) 
</span> 
</div> 
<!--l. 230--> 
<p class="noindent"> and Prolog will correctly reply 
</p> 
<div class="fancyvrb" id="fancyvrb245"> 
<a id="x34-47030r1"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;5 
</span> 
</div> 
<!--l. 234--> 
<p class="noindent"> Actually, you can even given Prolog the query 
</p> 
<div class="fancyvrb" id="fancyvrb246"> 
<a id="x34-47032r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;is(X,+(3,2)) 
</span> 
</div> 
<!--l. 238--> 
<p class="noindent"> and Prolog will respond 
</p> 
<div class="fancyvrb" id="fancyvrb247"> 
<a id="x34-47034r1"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;5 
</span> 
</div> 
<!--l. 242--> 
<p class="noindent"> This is because, for Prolog, the expression 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;+(3,2) 
</span> 
</span> really is the term 
<span class="verb"> 
<span class="cmtt-10"> is(X,+(3,2)) 
</span> 
</span> . The expression 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;+(3,2) 
</span> 
</span> is just user-friendly notation. Underneath, as always, Prolog is just working away with terms. 
</p> 
<!--l. 247--> 
<p class="indent"> Summing up, arithmetic in Prolog is easy to use. Pretty much all you have to remember is to use 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> to force evaluation, that stuff to be evaluated must go to the right of 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> , and to take care that any variables are correctly instantiated. But there is a deeper point that is worth reflecting on: bolting on the extra capability to do arithmetic in this way has further widened the gap between the procedural and declarative meanings of Prolog programs. 
</p> 
<!--l. 259--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse24"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse18"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse18"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse19"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse22"> up 
</a> ] 
</p> 
</div> 
<!--l. 259--> 
<p class="indent"> 
<a id="taillpn-htmlse19"> 
</a> 
</p> 