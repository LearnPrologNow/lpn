
<!--l. 22--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse29"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse20"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlch7"> up 
</a> ] 
</p> 
</div> 
<h3 class="sectionHead"> 
<span class="titlemark"> 6.1 
</span> 
<a id="x40-530006.1"> 
</a> Append 
</h3> 
<!--l. 26--> 
<p class="noindent"> We shall define an important predicate 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> whose arguments are all lists. Viewed declaratively, 
<span class="verb"> 
<span class="cmtt-10"> append(L1,L2,L3) 
</span> 
</span> will 
<a id="dx40-53001"> 
</a> hold when the list 
<span class="verb"> 
<span class="cmtt-10"> L3 
</span> 
</span> is the result of concatenating the lists 
<span class="verb"> 
<span class="cmtt-10"> L1 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> L2 
</span> 
</span> together (concatenating means joining the lists together, end to end). For example, if we pose the query 
</p> 
<div class="fancyvrb" id="fancyvrb279"> 
<a id="x40-53003r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;append([a,b,c],[1,2,3],[a,b,c,1,2,3]). 
</span> 
</div> 
<!--l. 35--> 
<p class="noindent"> or the query 
</p> 
<div class="fancyvrb" id="fancyvrb280"> 
<a id="x40-53005r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;append([a,[foo,gibble],c],[1,2,[[],b]], 
</span> 
<br class="fancyvrb" /> 
<a id="x40-53007r2"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;[a,[foo,gibble],c,1,2,[[],b]). 
</span> 
</div> 
<!--l. 40--> 
<p class="noindent"> we will get the response yes. On the other hand, if we pose the query 
</p> 
<div class="fancyvrb" id="fancyvrb281"> 
<a id="x40-53009r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;append([a,b,c],[1,2,3],[a,b,c,1,2]). 
</span> 
</div> 
<!--l. 45--> 
<p class="noindent"> or the query 
</p> 
<div class="fancyvrb" id="fancyvrb282"> 
<a id="x40-53011r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;append([a,b,c],[1,2,3],[1,2,3,a,b,c]). 
</span> 
</div> 
<!--l. 49--> 
<p class="noindent"> we will get the answer no. 
</p> 
<!--l. 52--> 
<p class="indent"> From a procedural perspective, the most obvious use of 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> is to concatenate two lists together. We can do this simply by using a variable as the third argument: the query 
</p> 
<div class="fancyvrb" id="fancyvrb283"> 
<a id="x40-53013r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;append([a,b,c],[1,2,3],L3). 
</span> 
</div> 
<!--l. 58--> 
<p class="noindent"> yields the response 
</p> 
<div class="fancyvrb" id="fancyvrb284"> 
<a id="x40-53015r1"> 
</a> 
<span class="cmtt-10"> L3 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a,b,c,1,2,3] 
</span> 
<br class="fancyvrb" /> 
<a id="x40-53017r2"> 
</a> 
<span class="cmtt-10"> yes 
</span> 
</div> 
<!--l. 64--> 
<p class="indent"> But (as we shall soon see) we can also use 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> to split up a list. In fact, 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> is a real workhorse. There&#8217;s lots we can do with it, and studying it is a good way to gain a better understanding of list processing in Prolog. 
</p> 
<!--l. 69--> 
<p class="noindent"> 
</p> 
<h4 class="likesubsectionHead"> 
<a id="x40-540006.1"> 
</a> Defining append 
</h4> 
<!--l. 73--> 
<p class="noindent"> Here&#8217;s how 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> is defined: 
</p> 
<div class="fancyvrb" id="fancyvrb285"> 
<a id="x40-54002r1"> 
</a> 
<span class="cmtt-10"> append([],L,L). 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54004r2"> 
</a> 
<span class="cmtt-10"> append([H|T],L2,[H|L3]) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;append(T,L2,L3). 
</span> 
</div> 
<!--l. 79--> 
<p class="indent"> This is a recursive definition. The base case simply says that appending the empty list to any list whatsoever yields that same list, which is obviously true. 
</p> 
<!--l. 83--> 
<p class="indent"> But what about the recursive step? This says that when we concatenate a non-empty list 
<span class="verb"> 
<span class="cmtt-10"> [H|T] 
</span> 
</span> with a list 
<span class="verb"> 
<span class="cmtt-10"> L2 
</span> 
</span> , we end up with the list whose head is 
<span class="verb"> 
<span class="cmtt-10"> H 
</span> 
</span> and whose tail is the result of concatenating 
<span class="verb"> 
<span class="cmtt-10"> T 
</span> 
</span> with 
<span class="verb"> 
<span class="cmtt-10"> L2 
</span> 
</span> . It may be useful to think about this definition pictorially: 
</p> 
<!--l. 91--> 
<p class="indent"> 
</p> 
<div class="quote"> 
<!--l. 92--> 
<p class="noindent"> Input: [ H 
<span class="cmsy-10"> &#x2223; 
</span> 
<span class="fbox"> &#x00A0;T &#x00A0; 
</span> ] + 
<span class="fbox"> &#x00A0;L2 &#x00A0; 
</span> 
<br class="newline" /> Result: [ H 
<span class="cmsy-10"> &#x2223; 
</span> 
<img src="html/lpn-html0x.png" alt="|----| ◟L ◝3◜-◞-" /> 
<sub> 
<span class="fbox"> T 
</span> 
<span class="cmr-7"> + 
</span> 
<span class="fbox"> L2 
</span> 
</sub> ] 
</p> 
</div> 
<!--l. 103--> 
<p class="indent"> But what is the procedural meaning of this definition? What actually goes on when we use 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> to glue two lists together? Let&#8217;s take a detailed look at what happens when we pose the query 
<span class="verb"> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;append([a,b,c],[1,2,3],X) 
</span> 
</span> . 
</p> 
<!--l. 108--> 
<p class="indent"> When we pose this query, Prolog will match it to the head of the recursive rule, generating a new internal variable (say 
<span class="verb"> 
<span class="cmtt-10"> _G518 
</span> 
</span> ) in the process. If we carried out a trace of what happens next, we would get something like the following: 
</p> 
<!--l. 113--> 
<p class="indent"> 
</p> 
<div class="fancyvrb" id="fancyvrb286"> 
<a id="x40-54006r1"> 
</a> 
<span class="cmtt-10"> append([a, 
</span> 
<span class="cmtt-10"> &#x00A0;b, 
</span> 
<span class="cmtt-10"> &#x00A0;c], 
</span> 
<span class="cmtt-10"> &#x00A0;[1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3], 
</span> 
<span class="cmtt-10"> &#x00A0;_G518) 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54008r2"> 
</a> 
<span class="cmtt-10"> append([b, 
</span> 
<span class="cmtt-10"> &#x00A0;c], 
</span> 
<span class="cmtt-10"> &#x00A0;[1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3], 
</span> 
<span class="cmtt-10"> &#x00A0;_G587) 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54010r3"> 
</a> 
<span class="cmtt-10"> append([c], 
</span> 
<span class="cmtt-10"> &#x00A0;[1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3], 
</span> 
<span class="cmtt-10"> &#x00A0;_G590) 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54012r4"> 
</a> 
<span class="cmtt-10"> append([], 
</span> 
<span class="cmtt-10"> &#x00A0;[1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3], 
</span> 
<span class="cmtt-10"> &#x00A0;_G593) 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54014r5"> 
</a> 
<span class="cmtt-10"> append([], 
</span> 
<span class="cmtt-10"> &#x00A0;[1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3], 
</span> 
<span class="cmtt-10"> &#x00A0;[1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3]) 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54016r6"> 
</a> 
<span class="cmtt-10"> append([c], 
</span> 
<span class="cmtt-10"> &#x00A0;[1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3], 
</span> 
<span class="cmtt-10"> &#x00A0;[c, 
</span> 
<span class="cmtt-10"> &#x00A0;1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3]) 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54018r7"> 
</a> 
<span class="cmtt-10"> append([b, 
</span> 
<span class="cmtt-10"> &#x00A0;c], 
</span> 
<span class="cmtt-10"> &#x00A0;[1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3], 
</span> 
<span class="cmtt-10"> &#x00A0;[b, 
</span> 
<span class="cmtt-10"> &#x00A0;c, 
</span> 
<span class="cmtt-10"> &#x00A0;1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3]) 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54020r8"> 
</a> 
<span class="cmtt-10"> append([a, 
</span> 
<span class="cmtt-10"> &#x00A0;b, 
</span> 
<span class="cmtt-10"> &#x00A0;c], 
</span> 
<span class="cmtt-10"> &#x00A0;[1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3], 
</span> 
<span class="cmtt-10"> &#x00A0;[a, 
</span> 
<span class="cmtt-10"> &#x00A0;b, 
</span> 
<span class="cmtt-10"> &#x00A0;c, 
</span> 
<span class="cmtt-10"> &#x00A0;1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3]) 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54022r9"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-54024r10"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a, 
</span> 
<span class="cmtt-10"> &#x00A0;b, 
</span> 
<span class="cmtt-10"> &#x00A0;c, 
</span> 
<span class="cmtt-10"> &#x00A0;1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3] 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54026r11"> 
</a> 
<span class="cmtt-10"> yes 
</span> 
</div> 
<!--l. 127--> 
<p class="indent"> The basic pattern should be clear: in the first four lines we see that Prolog recurses its way down the list in its first argument until it can apply the base case of the recursive definition. Then, as the next four lines show, it then stepwise &#8216;fills in&#8217; the result. How is this &#8216;filling in&#8217; process carried out? By successively instantiating the variables 
<span class="verb"> 
<span class="cmtt-10"> _G593 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> _G590 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> _G587 
</span> 
</span> , and 
<span class="verb"> 
<span class="cmtt-10"> _G518 
</span> 
</span> . But while it&#8217;s important to grasp this basic pattern, it doesn&#8217;t tell us all we need to know about the way 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> works, so let&#8217;s dig deeper. Here is the search tree for the query 
<span class="verb"> 
<span class="cmtt-10"> append([a,b,c],[1,2,3],X) 
</span> 
</span> . We&#8217;ll work carefully through all the steps, making a careful note of what our goals are, and what the variables are instantiated to. 
</p> 
<div class="center"> 
<!--l. 140--> 
<p class="noindent"> 
</p> 
<!--l. 141--> 
<p class="noindent"> 
<img src="html/chap6-pspic1.ps.png" alt="*Pic not found*" /> 
</p> 
</div> 
<!--l. 145--> 
<p class="indent"> 
</p> 
<ol class="enumerate1"> 
<li class="enumerate" id="x40-54028x1"> Goal 1: 
<span class="verb"> 
<span class="cmtt-10"> append([a,b,c],[1,2,3],_G518) 
</span> 
</span> . Prolog matches this to the head of the recursive rule (that is, 
<span class="verb"> 
<span class="cmtt-10"> append([H|T],L2,[H|L3]) 
</span> 
</span> ). Thus 
<span class="verb"> 
<span class="cmtt-10"> _G518 
</span> 
</span> is unified to 
<span class="verb"> 
<span class="cmtt-10"> [a|L3] 
</span> 
</span> , and Prolog has the new goal 
<span class="verb"> 
<span class="cmtt-10"> append([b,c],[1,2,3],L3) 
</span> 
</span> . It generates a new variable 
<span class="verb"> 
<span class="cmtt-10"> _G587 
</span> 
</span> for 
<span class="verb"> 
<span class="cmtt-10"> L3 
</span> 
</span> , thus we have that 
<span class="verb"> 
<span class="cmtt-10"> _G518 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a|_G587] 
</span> 
</span> . 
</li> 
<li class="enumerate" id="x40-54030x2"> Goal 2: 
<span class="verb"> 
<span class="cmtt-10"> append([b,c],[1,2,3],_G587) 
</span> 
</span> . Prolog matches this to the head of the recursive rule, thus 
<span class="verb"> 
<span class="cmtt-10"> _G587 
</span> 
</span> is unified to 
<span class="verb"> 
<span class="cmtt-10"> [b|L3] 
</span> 
</span> , and Prolog has the new goal 
<span class="verb"> 
<span class="cmtt-10"> append([c],[1,2,3],L3) 
</span> 
</span> . It generates the internal variable 
<span class="verb"> 
<span class="cmtt-10"> _G590 
</span> 
</span> for 
<span class="verb"> 
<span class="cmtt-10"> L3 
</span> 
</span> , thus we have that 
<span class="verb"> 
<span class="cmtt-10"> _G587 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[b|_G590] 
</span> 
</span> . 
</li> 
<li class="enumerate" id="x40-54032x3"> Goal 3: 
<span class="verb"> 
<span class="cmtt-10"> append([c],[1,2,3],_G590 
</span> 
</span> ). Prolog matches this to the head of the recursive rule, thus 
<span class="verb"> 
<span class="cmtt-10"> _G590 
</span> 
</span> is unified to 
<span class="verb"> 
<span class="cmtt-10"> [c|L3] 
</span> 
</span> , and Prolog has the new goal 
<span class="verb"> 
<span class="cmtt-10"> append([],[1,2,3],L3) 
</span> 
</span> . It generates the internal variable 
<span class="verb"> 
<span class="cmtt-10"> _G593 
</span> 
</span> for 
<span class="verb"> 
<span class="cmtt-10"> L3 
</span> 
</span> , thus we have that 
<span class="verb"> 
<span class="cmtt-10"> _G590 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[c|_G593] 
</span> 
</span> . 
</li> 
<li class="enumerate" id="x40-54034x4"> Goal 4: 
<span class="verb"> 
<span class="cmtt-10"> append([],[1,2,3],_G593 
</span> 
</span> ). At last: Prolog can use the base clause (that is, 
<span class="verb"> 
<span class="cmtt-10"> append([],L,L) 
</span> 
</span> ). And in the four successive matching steps, Prolog will obtain answers to Goal 4, Goal 3, Goal 2, and Goal 1. Here&#8217;s how. 
</li> 
<li class="enumerate" id="x40-54036x5"> Answer to Goal 4: 
<span class="verb"> 
<span class="cmtt-10"> append([],[1,2,3],[1,2,3]) 
</span> 
</span> . This is because when we match Goal 4 (that is, 
<span class="verb"> 
<span class="cmtt-10"> append([],[1,2,3],_G593) 
</span> 
</span> to the base clause, 
<span class="verb"> 
<span class="cmtt-10"> _G593 
</span> 
</span> is unified to 
<span class="verb"> 
<span class="cmtt-10"> [1,2,3] 
</span> 
</span> . 
</li> 
<li class="enumerate" id="x40-54038x6"> Answer to Goal 3: 
<span class="verb"> 
<span class="cmtt-10"> append([c],[1,2,3],[c,1,2,3]) 
</span> 
</span> . Why? Because Goal 3 is 
<span class="verb"> 
<span class="cmtt-10"> append([c],[1,2,3],_G590]) 
</span> 
</span> , and 
<span class="verb"> 
<span class="cmtt-10"> _G590 
</span> 
</span> is the list 
<span class="verb"> 
<span class="cmtt-10"> [c|_G593] 
</span> 
</span> , and we have just unified 
<span class="verb"> 
<span class="cmtt-10"> _G593 
</span> 
</span> to 
<span class="verb"> 
<span class="cmtt-10"> [1,2,3] 
</span> 
</span> . So 
<span class="verb"> 
<span class="cmtt-10"> _G590 
</span> 
</span> is unified to 
<span class="verb"> 
<span class="cmtt-10"> [c,1,2,3] 
</span> 
</span> . 
</li> 
<li class="enumerate" id="x40-54040x7"> Answer to Goal 2: 
<span class="verb"> 
<span class="cmtt-10"> append([b,c],[1,2,3],[b,c,1,2,3]) 
</span> 
</span> . Why? Because Goal 2 is 
<span class="verb"> 
<span class="cmtt-10"> append([b,c],[1,2,3],_G587]) 
</span> 
</span> , and 
<span class="verb"> 
<span class="cmtt-10"> _G587 
</span> 
</span> is the list 
<span class="verb"> 
<span class="cmtt-10"> [b|_G590] 
</span> 
</span> , and we have just unified 
<span class="verb"> 
<span class="cmtt-10"> _G590 
</span> 
</span> to 
<span class="verb"> 
<span class="cmtt-10"> [c,1,2,3] 
</span> 
</span> . So 
<span class="verb"> 
<span class="cmtt-10"> _G587 
</span> 
</span> is unified to 
<span class="verb"> 
<span class="cmtt-10"> [b,c,1,2,3] 
</span> 
</span> . 
</li> 
<li class="enumerate" id="x40-54042x8"> Answer to Goal 1: 
<span class="verb"> 
<span class="cmtt-10"> append([a,b,c],[1,2,3],[a,b,c,1,2,3]) 
</span> 
</span> . Why? Because Goal 2 is 
<span class="verb"> 
<span class="cmtt-10"> append([a,b,c],[1,2,3],_G518]) 
</span> 
</span> , and 
<span class="verb"> 
<span class="cmtt-10"> _G518 
</span> 
</span> is the list 
<span class="verb"> 
<span class="cmtt-10"> [a|_G587] 
</span> 
</span> , and we have just unified 
<span class="verb"> 
<span class="cmtt-10"> _G587 
</span> 
</span> to 
<span class="verb"> 
<span class="cmtt-10"> [b,c,1,2,3] 
</span> 
</span> . So 
<span class="verb"> 
<span class="cmtt-10"> _G518 
</span> 
</span> is unified to 
<span class="verb"> 
<span class="cmtt-10"> [a,b,c,1,2,3] 
</span> 
</span> . 
</li> 
<li class="enumerate" id="x40-54044x9"> Thus Prolog now knows how to instantiate 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> , the original query variable. It tells us that 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a,b,c,1,2,3] 
</span> 
</span> , which is what we want. 
</li> 
</ol> 
<!--l. 200--> 
<p class="indent"> Work through this example carefully, and make sure you fully understand the pattern of variable instantiations, namely: 
</p> 
<div class="fancyvrb" id="fancyvrb287"> 
<a id="x40-54046r1"> 
</a> 
<span class="cmtt-10"> _G518 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a|_G587] 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54048r2"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a|[b|_G590]] 
</span> 
<br class="fancyvrb" /> 
<a id="x40-54050r3"> 
</a> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a|[b|[c|_G593]]] 
</span> 
</div> 
<!--l. 207--> 
<p class="noindent"> This type of pattern lies at the heart of the way 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> works. Moreover, it illustrates a more general theme: the use of unification to build structure. In a nutshell, the recursive calls to 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> build up this nested pattern of variables which code up the required answer. When Prolog finally instantiates the innermost variable 
<span class="verb"> 
<span class="cmtt-10"> _G593 
</span> 
</span> to 
<span class="verb"> 
<span class="cmtt-10"> [1, 
</span> 
<span class="cmtt-10"> &#x00A0;2, 
</span> 
<span class="cmtt-10"> &#x00A0;3] 
</span> 
</span> , the answer crystallises out, like a snowflake forming around a grain of dust. But it is unification, not magic, that produces the result. 
</p> 
<!--l. 218--> 
<p class="noindent"> 
</p> 
<h4 class="likesubsectionHead"> 
<a id="x40-550006.1"> 
</a> Using append 
</h4> 
<!--l. 222--> 
<p class="noindent"> Now that we understand how 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> works, let&#8217;s see how we can put it to work. 
</p> 
<!--l. 225--> 
<p class="indent"> One important use of 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> is to split up a list into two consecutive lists. For example: 
</p> 
<div class="fancyvrb" id="fancyvrb288"> 
<a id="x40-55002r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;append(X,Y,[a,b,c,d]). 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55004r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55006r3"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[] 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55008r4"> 
</a> 
<span class="cmtt-10"> Y 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a,b,c,d] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55010r5"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55012r6"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a] 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55014r7"> 
</a> 
<span class="cmtt-10"> Y 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[b,c,d] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55016r8"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55018r9"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a,b] 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55020r10"> 
</a> 
<span class="cmtt-10"> Y 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[c,d] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55022r11"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55024r12"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a,b,c] 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55026r13"> 
</a> 
<span class="cmtt-10"> Y 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[d] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55028r14"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55030r15"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a,b,c,d] 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55032r16"> 
</a> 
<span class="cmtt-10"> Y 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55034r17"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55036r18"> 
</a> 
<span class="cmtt-10"> no 
</span> 
</div> 
<!--l. 248--> 
<p class="indent"> That is, we give the list we want to split up (here 
<span class="verb"> 
<span class="cmtt-10"> [a,b,c,d] 
</span> 
</span> ) to 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> as the third argument, and we use variables for the first two arguments. Prolog then searches for ways of instantiating the variables to two lists that concatenate to give the third argument, thus splitting up the list in two. Moreover, as this example shows, by backtracking, Prolog can find all possible ways of splitting up a list into two consecutive lists. 
</p> 
<!--l. 256--> 
<p class="indent"> This ability means it is easy to define some useful predicates with 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> . Let&#8217;s consider some examples. First, we can define a program which finds prefixes of lists. For example, the prefixes of 
<span class="verb"> 
<span class="cmtt-10"> [a,b,c,d] 
</span> 
</span> are 
<span class="verb"> 
<span class="cmtt-10"> [] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [a] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [a,b] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [a,b,c] 
</span> 
</span> , and 
<span class="verb"> 
<span class="cmtt-10"> [a,b,c,d] 
</span> 
</span> . With the help of 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> it is straightforward to define a program 
<span class="verb"> 
<span class="cmtt-10"> prefix/2 
</span> 
</span> , whose arguments are both lists, such that 
<span class="verb"> 
<span class="cmtt-10"> prefix(P,L) 
</span> 
</span> will hold when 
<span class="verb"> 
<span class="cmtt-10"> P 
</span> 
</span> is a prefix of 
<span class="verb"> 
<span class="cmtt-10"> L 
</span> 
</span> . Here&#8217;s how: 
</p> 
<div class="fancyvrb" id="fancyvrb289"> 
<a id="x40-55038r1"> 
</a> 
<span class="cmtt-10"> prefix(P,L):- 
</span> 
<span class="cmtt-10"> &#x00A0;append(P,_,L). 
</span> 
</div> 
<!--l. 268--> 
<p class="indent"> This says that list 
<span class="verb"> 
<span class="cmtt-10"> P 
</span> 
</span> is a prefix of list 
<span class="verb"> 
<span class="cmtt-10"> L 
</span> 
</span> when there is some list such that 
<span class="verb"> 
<span class="cmtt-10"> L 
</span> 
</span> is the result of concatenating 
<span class="verb"> 
<span class="cmtt-10"> P 
</span> 
</span> with that list. (We use the anonymous variable since we don&#8217;t care what that other list is: we only care that there is some such list or other.) This predicate successfully finds prefixes of lists, and moreover, via backtracking, finds them all: 
</p> 
<div class="fancyvrb" id="fancyvrb290"> 
<a id="x40-55040r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;prefix(X,[a,b,c,d]). 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55042r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55044r3"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55046r4"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55048r5"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55050r6"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55052r7"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a,b] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55054r8"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55056r9"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a,b,c] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55058r10"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55060r11"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a,b,c,d] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55062r12"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55064r13"> 
</a> 
<span class="cmtt-10"> no 
</span> 
</div> 
<!--l. 291--> 
<p class="indent"> In a similar fashion, we can define a program which finds suffixes of lists. For example, the suffixes of 
<span class="verb"> 
<span class="cmtt-10"> [a,b,c,d] 
</span> 
</span> are 
<span class="verb"> 
<span class="cmtt-10"> [] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [d] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [c,d] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [b,c,d] 
</span> 
</span> , and 
<span class="verb"> 
<span class="cmtt-10"> [a,b,c,d] 
</span> 
</span> . Again, using 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> it is easy to define 
<span class="verb"> 
<span class="cmtt-10"> suffix/2 
</span> 
</span> , a predicate whose arguments are both lists, such that 
<span class="verb"> 
<span class="cmtt-10"> suffix(S,L) 
</span> 
</span> will hold when 
<span class="verb"> 
<span class="cmtt-10"> S 
</span> 
</span> is a suffix of 
<span class="verb"> 
<span class="cmtt-10"> L 
</span> 
</span> : 
</p> 
<div class="fancyvrb" id="fancyvrb291"> 
<a id="x40-55066r1"> 
</a> 
<span class="cmtt-10"> suffix(S,L):- 
</span> 
<span class="cmtt-10"> &#x00A0;append(_,S,L). 
</span> 
</div> 
<!--l. 301--> 
<p class="noindent"> That is, list 
<span class="verb"> 
<span class="cmtt-10"> S 
</span> 
</span> is a suffix of list 
<span class="verb"> 
<span class="cmtt-10"> L 
</span> 
</span> if there is some list such that 
<span class="verb"> 
<span class="cmtt-10"> L 
</span> 
</span> is the result of concatenating that list with 
<span class="verb"> 
<span class="cmtt-10"> S 
</span> 
</span> . This predicate successfully finds suffixes of lists, and moreover, via backtracking, finds them all: 
</p> 
<div class="fancyvrb" id="fancyvrb292"> 
<a id="x40-55068r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;suffix(X,[a,b,c,d]). 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55070r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55072r3"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[a,b,c,d] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55074r4"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55076r5"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[b,c,d] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55078r6"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55080r7"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[c,d] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55082r8"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55084r9"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[d] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55086r10"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55088r11"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x40-55090r12"> 
</a> 
<br class="fancyvrb" /> 
<a id="x40-55092r13"> 
</a> 
<span class="cmtt-10"> no 
</span> 
</div> 
<!--l. 321--> 
<p class="indent"> Make sure you understand why the results come out in this order. 
</p> 
<!--l. 325--> 
<p class="indent"> And now it&#8217;s very easy to define a program that finds sublists of lists. The sublists of 
<span class="verb"> 
<span class="cmtt-10"> [a,b,c,d] 
</span> 
</span> are 
<span class="verb"> 
<span class="cmtt-10"> [] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [a] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [b] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [c] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [d] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [a,b] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [b,c] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [c,d] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [a,b,c] 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> [b,c,d] 
</span> 
</span> , and 
<span class="verb"> 
<span class="cmtt-10"> [a,b,c,d] 
</span> 
</span> . A little thought reveals that the sublists of a list L are simply the 
<span class="cmti-10"> prefixes of suffixes of 
</span> L. Think about it pictorially: 
</p> 
<!--l. 334--> 
<p class="indent"> 
</p> 
<div class="quote"> 
<!--l. 335--> 
<p class="noindent"> Take suffix: 
<span class="fbox"> 
<span class="cmmi-10"> a,b,c,d,e,f,g, 
</span> 
<img src="html/lpn-html1x.png" alt="h,i,j,k,l,m, n,o,p ◟------◝◜------◞" /> 
</span> 
<br class="newline" /> Take prefix: &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0; 
<span class="fbox"> 
<img src="html/lpn-html2x.png" alt="h,i,j,k,l ◟ ◝◜ ◞" /> 
<span class="cmmi-10"> ,m,n,o,p 
</span> 
</span> 
<br class="newline" /> Result: &#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0; 
<span class="fbox"> 
<span class="cmmi-10"> h,i,j,k,l 
</span> 
</span> 
</p> 
</div> 
<!--l. 341--> 
<p class="indent"> As we already have defined the predicates for producing suffixes and prefixes of lists, we simply define a sublist as: 
</p> 
<div class="fancyvrb" id="fancyvrb293"> 
<a id="x40-55094r1"> 
</a> 
<span class="cmtt-10"> sublist(SubL,L):- 
</span> 
<span class="cmtt-10"> &#x00A0;suffix(S,L), 
</span> 
<span class="cmtt-10"> &#x00A0;prefix(SubL,S). 
</span> 
</div> 
<!--l. 346--> 
<p class="noindent"> That is, 
<span class="verb"> 
<span class="cmtt-10"> SubL 
</span> 
</span> is a sublist of 
<span class="verb"> 
<span class="cmtt-10"> L 
</span> 
</span> if there is some suffix 
<span class="verb"> 
<span class="cmtt-10"> S 
</span> 
</span> of 
<span class="verb"> 
<span class="cmtt-10"> L 
</span> 
</span> of which 
<span class="verb"> 
<span class="cmtt-10"> SubL 
</span> 
</span> is a prefix. This program doesn&#8217;t 
<span class="cmti-10"> explicitly 
</span> use 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> , but of course, under the surface, that&#8217;s what&#8217;s doing the work for us, as both 
<span class="verb"> 
<span class="cmtt-10"> prefix/2 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> suffix/2 
</span> 
</span> are defined using 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> . 
</p> 
<!--l. 355--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse29"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse24"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlch7"> up 
</a> ] 
</p> 
</div> 
<!--l. 355--> 
<p class="indent"> 
<a id="taillpn-htmlse24"> 
</a> 
</p> 