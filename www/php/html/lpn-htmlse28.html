
<!--l. 23--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse34"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse24"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlch8"> up 
</a> ] 
</p> 
</div> 
<h3 class="sectionHead"> 
<span class="titlemark"> 7.1 
</span> 
<a id="x45-620007.1"> 
</a> Context Free Grammars 
</h3> 
<!--l. 25--> 
<p class="noindent"> Prolog has been used for many purposes, but its inventor, Alain Colmerauer, was interested in computational linguistics, and this remains a classic application for the language. Moreover, Prolog offers a number of tools which make life easier for computational linguists, and we are now going to start learning about one of the most useful of these: definite clause grammars, or DCGs as they are usually called. 
</p> 
<!--l. 33--> 
<p class="indent"> DCGs are a special notation for defining grammars. So, before we go any further, we&#8217;d better learn what a grammar is. We shall do so by discussing context free grammars (or CFGs). The basic idea of context free grammars is simple to understand, but don&#8217;t be fooled into thinking that CFGs are toys. They&#8217;re not. While CFGs aren&#8217;t powerful enough to cope with the syntactic structure of all natural languages (that is, the kind of languages that human beings use), they can certainly handle most aspects of the syntax of many natural languages (for example, English and French) in a reasonably natural way. 
</p> 
<!--l. 44--> 
<p class="indent"> So what is a context free grammar? In essence, a finite collection of rules which tell us that certain sentences are grammatical (that is, syntactically correct) and what their grammatical structure actually is. Here&#8217;s a simple context free grammar for a small fragment of English: 
</p> 
<div class="center"> 
<!--l. 51--> 
<p class="noindent"> 
</p> 
<div class="tabular"> 
<table id="TBL-3" class="tabular" cellspacing="0" cellpadding="0"> 
<colgroup id="TBL-3-1g"> 
<col id="TBL-3-1" /> 
</colgroup> 
<tr style="vertical-align:baseline;" id="TBL-3-1-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-3-1-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
<span class="cmtt-10"> &#x00A0;np 
</span> 
<span class="cmtt-10"> &#x00A0;vp 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-3-2-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-3-2-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> np 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
<span class="cmtt-10"> &#x00A0;det 
</span> 
<span class="cmtt-10"> &#x00A0;n 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-3-3-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-3-3-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> vp 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
<span class="cmtt-10"> &#x00A0;v 
</span> 
<span class="cmtt-10"> &#x00A0;np 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-3-4-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-3-4-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> vp 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
<span class="cmtt-10"> &#x00A0;v 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-3-5-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-3-5-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> det 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
</span> 
<span class="cmti-10"> a 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-3-6-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-3-6-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> det 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
</span> 
<span class="cmti-10"> the 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-3-7-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-3-7-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> n 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
</span> 
<span class="cmti-10"> woman 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-3-8-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-3-8-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> n 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
</span> 
<span class="cmti-10"> man 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-3-9-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-3-9-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> v 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
</span> 
<span class="cmti-10"> shoots 
</span> 
</td> 
</tr> 
</table> 
</div> 
</div> 
<!--l. 63--> 
<p class="indent"> What are the ingredients of this little grammar? Well, first note that it contains three types of symbol. There&#8217;s 
<span class="verb"> 
<span class="cmtt-10"> -&#x003E; 
</span> 
</span> , which is used to define the rules. Then there are the symbols written like this: 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> np 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> vp 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> det 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> n 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> v 
</span> 
</span> . These symbols are called non-terminal symbols; we&#8217;ll soon learn why. Each of these symbols has a traditional meaning in linguistics: 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
</span> is short for sentence, 
<span class="verb"> 
<span class="cmtt-10"> np 
</span> 
</span> is short for noun phrase, 
<span class="verb"> 
<span class="cmtt-10"> vp 
</span> 
</span> is short for verb phrase, and 
<span class="verb"> 
<span class="cmtt-10"> det 
</span> 
</span> is short for determiner. That is, each of these symbols is shorthand for a grammatical category. Finally there are the symbols in italics: 
<span class="cmti-10"> a, the, woman, man 
</span> , and 
<span class="cmti-10"> shoots 
</span> . These are terminal symbols, though a computer scientist might call them the alphabet, and linguists might call them lexical items. We&#8217;ll usually just call them words. 
</p> 
<!--l. 77--> 
<p class="indent"> This grammar contains nine context free rules. A context free rule consists of a single non-terminal symbol, followed by 
<span class="verb"> 
<span class="cmtt-10"> -&#x003E; 
</span> 
</span> , followed by a finite sequence made up of terminal and/or non-terminal symbols. All nine items listed above have this form, so they are all legitimate context free rules. What do these rules mean? They tell us how different grammatical categories can be built up. Read 
<span class="verb"> 
<span class="cmtt-10"> -&#x003E; 
</span> 
</span> as 
<span class="cmti-10"> can consist of 
</span> , or 
<span class="cmti-10"> can be built out of 
</span> . For example, the first rule tells us that a sentence can consist of a noun phrase followed by a verb phrase. The third rule tells us that a verb phrase can consist of a verb followed by a noun phrase, while the fourth rule tells us that there is another way to build a verb phrase: simply use a verb. The last five rules tell us that 
<span class="cmti-10"> a 
</span> and 
<span class="cmti-10"> the 
</span> are determiners, that 
<span class="cmti-10"> man 
</span> and 
<span class="cmti-10"> woman 
</span> are nouns, and that 
<span class="cmti-10"> shoots 
</span> is a verb. 
</p> 
<!--l. 92--> 
<p class="indent"> Now consider the string of words 
<span class="cmti-10"> a woman shoots a man 
</span> . Is this grammatical according to our little grammar? And if it is, what structure does it have? The following tree answers both questions: 
</p> 
<!--l. 96--> 
<p class="indent"> 
</p> 
<div class="quote"> 
<!--l. 110--> 
<p class="noindent"> 
<span class="cmtt-10"> s 
</span> 
<span class="cmtt-10"> np 
</span> 
<span class="cmtt-10"> det 
</span> 
<span class="cmtt-10"> a 
</span> 
<span class="cmtt-10"> n 
</span> 
<span class="cmtt-10"> woman 
</span> 
<span class="cmtt-10"> vp 
</span> 
<span class="cmtt-10"> v 
</span> 
<span class="cmtt-10"> shoots 
</span> 
<span class="cmtt-10"> np 
</span> 
<span class="cmtt-10"> det 
</span> 
<span class="cmtt-10"> a 
</span> 
<span class="cmtt-10"> n 
</span> 
<span class="cmtt-10"> man 
</span> 
</p> 
</div> 
<!--l. 116--> 
<p class="indent"> Right at the top we have a node marked 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
</span> . This node has two daughters, one marked 
<span class="verb"> 
<span class="cmtt-10"> np 
</span> 
</span> , and one marked 
<span class="verb"> 
<span class="cmtt-10"> vp 
</span> 
</span> . Note that this part of the diagram agrees with the first rule of the grammar, which says that an 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
</span> can be built out of an 
<span class="verb"> 
<span class="cmtt-10"> np 
</span> 
</span> and a 
<span class="verb"> 
<span class="cmtt-10"> vp 
</span> 
</span> . (A linguist would say that this part of the tree is licensed by the first rule.) In fact, as you can see, 
<span class="cmti-10"> every 
</span> part of the tree is licensed by one of our rules. For example, the two nodes marked 
<span class="verb"> 
<span class="cmtt-10"> np 
</span> 
</span> are licensed by the rule that says that an 
<span class="verb"> 
<span class="cmtt-10"> np 
</span> 
</span> can consist of a 
<span class="verb"> 
<span class="cmtt-10"> det 
</span> 
</span> followed by an 
<span class="verb"> 
<span class="cmtt-10"> n 
</span> 
</span> . And, right at the bottom of the diagram, all the words in 
<span class="cmti-10"> a woman shoots a man 
</span> are licensed by a rule. Incidentally, note that the terminal symbols only decorate the nodes right at the bottom of the tree (the terminal nodes) while non-terminal symbols only decorate nodes that are higher up in the tree (the non-terminal nodes). 
</p> 
<!--l. 133--> 
<p class="indent"> Such a tree is called a parse tree. Parse trees are important because they give us two kinds of information. Firstly, they give us information about strings. Secondly, they give us information about structure. This is an important distinction to grasp, so let&#8217;s have a closer look, and learn some important terminology while we are doing so. 
</p> 
<!--l. 140--> 
<p class="indent"> First, if we are given a string of words, and a grammar, and it turns out that we 
<span class="cmti-10"> can 
</span> build a parse tree like the one above (that is, a tree that has 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
</span> at the top node, and every node in the tree is licensed by the grammar, and the string of words we were given is listed in the correct order along the terminal nodes) then we say that the string is grammatical (according to the given grammar). For example, the string 
<span class="cmti-10"> a woman shoots a man 
</span> is grammatical according to our little grammar (and indeed, any reasonable grammar of English would classify it as grammatical). On the other hand, if there isn&#8217;t any such tree, the string is ungrammatical (according to the given grammar). For example, the string 
<span class="cmti-10"> woman a woman man a shoots 
</span> is ungrammatical according to our little grammar (and any reasonable grammar of English would classify it as ungrammatical). The language generated by a grammar consists of all the strings that the grammar classifies as grammatical. For example, 
<span class="cmti-10"> a woman shoots a 
</span> 
<span class="cmti-10"> man 
</span> also belongs to the language generated by our little grammar, and so does 
<span class="cmti-10"> a man shoots the woman 
</span> . A context free recogniser is a program which correctly tells us whether or not a string belongs to the language generated by a context free grammar. To put it another way, a recogniser is a program that correctly classifies strings as grammatical or ungrammatical (relative to some grammar). 
</p> 
<!--l. 162--> 
<p class="indent"> But often, in both linguistics and computer science, we are not merely interested in whether a string is grammatical or not, we also want to know 
<span class="cmti-10"> why 
</span> it is grammatical. More precisely, we often want to know what its structure is, and this is exactly the information a parse tree gives us. For example, the above parse tree shows us how the words in 
<span class="cmti-10"> a woman shoots a man 
</span> fit together, piece by piece, to form the sentence. This kind of information would be important if we were using this sentence in some application and needed to say what it actually meant (that is, if we wanted to do semantics). A context free parser is a program which correctly decides whether a string belongs to the language generated by a context free grammar 
<span class="cmti-10"> and also tells us what its structure is 
</span> . That is, whereas a recogniser merely says &#8220;Yes, grammatical&#8221; or &#8220;No, ungrammatical&#8221; to each string, a parser actually builds the associated parse tree and gives it to us. 
</p> 
<!--l. 179--> 
<p class="indent"> It remains to explain one final concept, namely what a context free language is. (Don&#8217;t get confused: we&#8217;ve told you what a context free 
<span class="cmti-10"> grammar 
</span> is, but not what a context free 
<span class="cmti-10"> language 
</span> is.) Quite simply, a context free language is a language that can be generated by a context free grammar. Some languages are context free, and some are not. For example, it seems plausible that English is a context free language. That is, it is probably possible to write a context free grammar that generates all (and only) the sentences that native speakers find acceptable. On the other hand, some dialects of Swiss-German are 
<span class="cmti-10"> not 
</span> context free. It can be proved mathematically that no context free grammar can generate all (and only) the sentences that native speakers of Swiss-German find acceptable. 
<span class="footnote-mark"> 
<a href="lpnpage.php?pagetype=html&pageid=lpn-html46"> 
<sup class="textsuperscript"> 1 
</sup> 
</a> 
</span> 
<a id="x45-62001f1"> 
</a> So if you wanted to write a grammar for such dialects, you would have to employ additional grammatical mechanisms, not merely context free rules. 
</p> 
<h4 class="likesubsectionHead"> 
<a id="x45-630007.1"> 
</a> CFG recognition using append 
</h4> 
<!--l. 206--> 
<p class="noindent"> That&#8217;s the theory, but how do we work with context free grammars in Prolog? To make things concrete: suppose we are given a context free grammar. How can we write a recogniser for it? And how can we write a parser for it? In this chapter we&#8217;ll look at the first question in detail. We&#8217;ll first show how (rather naive) recognisers can be written in Prolog, and then show how more sophisticated recognisers can be written with the help of difference lists. This discussion will lead us to definite clause grammars, Prolog&#8217;s built-in grammar tool. In the following chapter we&#8217;ll look at definite clause grammars in more detail, and learn (among other things) how to use them to define parsers. 
</p> 
<!--l. 218--> 
<p class="indent"> So: given a context free grammar, how do we define a recogniser in Prolog? In fact, Prolog offers a very direct answer to this question: we can simply write down Prolog clauses that correspond, in an obvious way, to the grammar rules. That is, we can simply turn the grammar into Prolog. 
</p> 
<!--l. 224--> 
<p class="indent"> Here&#8217;s a simple (though as we shall learn, inefficient) way of doing this. We shall use lists to represent strings. For example, we shall use the list 
<span class="verb"> 
<span class="cmtt-10"> [a,woman,shoots,a,man] 
</span> 
</span> to represent the string 
<span class="cmti-10"> a woman shoots a man 
</span> . Now, we have already said that the 
<span class="verb"> 
<span class="cmtt-10"> -&#x003E; 
</span> 
</span> symbol used in context free grammars means 
<span class="cmti-10"> can 
</span> 
<span class="cmti-10"> consist of 
</span> , or 
<span class="cmti-10"> can be built out of 
</span> , and this idea is easily modelled using lists. For example, the rule 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
<span class="cmtt-10"> &#x00A0;np 
</span> 
<span class="cmtt-10"> &#x00A0;vp 
</span> 
</span> can be thought of as saying: a list of words is an 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
</span> list if it is the result of concatenating an 
<span class="verb"> 
<span class="cmtt-10"> np 
</span> 
</span> list with a 
<span class="verb"> 
<span class="cmtt-10"> vp 
</span> 
</span> list. As we know how to concatenate lists in Prolog (we can use 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> ), it should be easy to turn these kinds of rules into Prolog. And what about the rules that tell us about individual words? Even easier: we can simply view 
<span class="verb"> 
<span class="cmtt-10"> n 
</span> 
<span class="cmtt-10"> &#x00A0;-&#x003E; 
</span> 
</span> 
<span class="cmti-10"> woman 
</span> as saying that the list 
<span class="verb"> 
<span class="cmtt-10"> [woman] 
</span> 
</span> is an 
<span class="verb"> 
<span class="cmtt-10"> n 
</span> 
</span> list. 
</p> 
<!--l. 239--> 
<p class="indent"> If we turn these ideas into Prolog, this is what we get: 
</p> 
<div class="fancyvrb" id="fancyvrb308"> 
<a id="x45-63002r1"> 
</a> 
<span class="cmtt-10"> s(Z):- 
</span> 
<span class="cmtt-10"> &#x00A0;np(X), 
</span> 
<span class="cmtt-10"> &#x00A0;vp(Y), 
</span> 
<span class="cmtt-10"> &#x00A0;append(X,Y,Z). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63004r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63006r3"> 
</a> 
<span class="cmtt-10"> np(Z):- 
</span> 
<span class="cmtt-10"> &#x00A0;det(X), 
</span> 
<span class="cmtt-10"> &#x00A0;n(Y), 
</span> 
<span class="cmtt-10"> &#x00A0;append(X,Y,Z). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63008r4"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63010r5"> 
</a> 
<span class="cmtt-10"> vp(Z):- 
</span> 
<span class="cmtt-10"> &#x00A0;v(X), 
</span> 
<span class="cmtt-10"> &#x00A0;np(Y), 
</span> 
<span class="cmtt-10"> &#x00A0;append(X,Y,Z). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63012r6"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63014r7"> 
</a> 
<span class="cmtt-10"> vp(Z):- 
</span> 
<span class="cmtt-10"> &#x00A0;v(Z). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63016r8"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63018r9"> 
</a> 
<span class="cmtt-10"> det([the]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63020r10"> 
</a> 
<span class="cmtt-10"> det([a]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63022r11"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63024r12"> 
</a> 
<span class="cmtt-10"> n([woman]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63026r13"> 
</a> 
<span class="cmtt-10"> n([man]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63028r14"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63030r15"> 
</a> 
<span class="cmtt-10"> v([shoots]). 
</span> 
</div> 
<!--l. 259--> 
<p class="indent"> The correspondence between the CFG rules and the Prolog code should be clear. And to use this program as a recogniser, we simply pose the obvious queries. For example: 
</p> 
<div class="fancyvrb" id="fancyvrb309"> 
<a id="x45-63032r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;s([a,woman,shoots,a,man]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63034r2"> 
</a> 
<span class="cmtt-10"> yes 
</span> 
</div> 
<!--l. 267--> 
<p class="indent"> In fact, because this is a simple declarative Prolog program, we can do more than this: we can also generate all the sentences this grammar produces. Our little grammar generates 20 sentences. Here are the first five: 
</p> 
<div class="fancyvrb" id="fancyvrb310"> 
<a id="x45-63036r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;s(X). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63038r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63040r3"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[the,woman,shoots,the,woman] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63042r4"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63044r5"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[the,woman,shoots,the,man] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63046r6"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63048r7"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[the,woman,shoots,a,woman] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63050r8"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63052r9"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[the,woman,shoots,a,man] 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63054r10"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63056r11"> 
</a> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;[the,woman,shoots] 
</span> 
</div> 
<!--l. 285--> 
<p class="indent"> Moreover, we&#8217;re not restricted to posing questions about sentences: we can ask about other grammatical categories. For example: 
</p> 
<div class="fancyvrb" id="fancyvrb311"> 
<a id="x45-63058r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;np([a,woman]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63060r2"> 
</a> 
<span class="cmtt-10"> yes 
</span> 
</div> 
<!--l. 292--> 
<p class="indent"> And we can generate noun phrases with the following query. 
</p> 
<div class="fancyvrb" id="fancyvrb312"> 
<a id="x45-63062r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;np(X). 
</span> 
</div> 
<!--l. 298--> 
<p class="indent"> Now this is rather nice. We have a simple, easy to understand program which corresponds with our CFG in an obvious way. Moreover, if we added more rules to our CFG, it would be easy to alter the program to cope with the new rules. 
</p> 
<!--l. 303--> 
<p class="indent"> But there is a problem: the program doesn&#8217;t use the input sentence to guide the search. Make a trace for the query 
<span class="verb"> 
<span class="cmtt-10"> s([a,man,shoots]) 
</span> 
</span> and you will see that the program chooses noun phrases and verb phrases and only afterwards checks whether these can be combined to form the sentence 
<span class="verb"> 
<span class="cmtt-10"> [a,man,shoots] 
</span> 
</span> . For example, Prolog will find that 
<span class="verb"> 
<span class="cmtt-10"> [the,woman] 
</span> 
</span> is a noun phrase and 
<span class="verb"> 
<span class="cmtt-10"> [shoots,the,woman] 
</span> 
</span> a verb phrase and only then will it check whether concatenating these lists happens to yield 
<span class="verb"> 
<span class="cmtt-10"> [a,man,shoots] 
</span> 
</span> , which of course it won&#8217;t. So, Prolog starts to backtrack, and the next thing it will try is whether concatenating the noun phrase 
<span class="verb"> 
<span class="cmtt-10"> [the,woman] 
</span> 
</span> and the verb phrase 
<span class="verb"> 
<span class="cmtt-10"> [shoots,the,man] 
</span> 
</span> happens to yield 
<span class="verb"> 
<span class="cmtt-10"> [a,man,shoots] 
</span> 
</span> , another non-starter. It will go on like this until it (finally) produces the noun phrase 
<span class="verb"> 
<span class="cmtt-10"> [a,man] 
</span> 
</span> and the verb phrase 
<span class="verb"> 
<span class="cmtt-10"> [shoots] 
</span> 
</span> . The problem is that the goals 
<span class="verb"> 
<span class="cmtt-10"> np(X) 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> vp(Y) 
</span> 
</span> are called with uninstantiated variables as arguments. 
</p> 
<!--l. 322--> 
<p class="indent"> So, how about changing the rules in such a way that 
<span class="verb"> 
<span class="cmtt-10"> append 
</span> 
</span> becomes the first goal: 
</p> 
<div class="fancyvrb" id="fancyvrb313"> 
<a id="x45-63064r1"> 
</a> 
<span class="cmtt-10"> s(Z):- 
</span> 
<span class="cmtt-10"> &#x00A0;append(X,Y,Z), 
</span> 
<span class="cmtt-10"> &#x00A0;np(X), 
</span> 
<span class="cmtt-10"> &#x00A0;vp(Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63066r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63068r3"> 
</a> 
<span class="cmtt-10"> np(Z):- 
</span> 
<span class="cmtt-10"> &#x00A0;append(X,Y,Z), 
</span> 
<span class="cmtt-10"> &#x00A0;det(X), 
</span> 
<span class="cmtt-10"> &#x00A0;n(Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63070r4"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63072r5"> 
</a> 
<span class="cmtt-10"> vp(Z):- 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;append(X,Y,Z), 
</span> 
<span class="cmtt-10"> &#x00A0;v(X), 
</span> 
<span class="cmtt-10"> &#x00A0;np(Y). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63074r6"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63076r7"> 
</a> 
<span class="cmtt-10"> vp(Z):- 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;v(Z). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63078r8"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63080r9"> 
</a> 
<span class="cmtt-10"> det([the]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63082r10"> 
</a> 
<span class="cmtt-10"> det([a]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63084r11"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63086r12"> 
</a> 
<span class="cmtt-10"> n([woman]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63088r13"> 
</a> 
<span class="cmtt-10"> n([man]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-63090r14"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-63092r15"> 
</a> 
<span class="cmtt-10"> v([shoots]). 
</span> 
</div> 
<!--l. 342--> 
<p class="indent"> Here we first use 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> to split up the input list. This instantiates the variables 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> , so that the other goals are all called with instantiated arguments. However, this program is still not very appealing: it uses 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> a lot and, even worse, it uses 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> with uninstantiated variables in the first two arguments. We saw in the previous chapter that this is a source of inefficiency. And indeed, the performance of this recogniser is very bad. It is revealing to trace through what actually happens when this program analyses a sentence such as 
<span class="cmti-10"> a woman shoots a 
</span> 
<span class="cmti-10"> man 
</span> . As you will see, relatively few of the steps are devoted to the real task of recognising the sentences: most are devoted to using 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> to decompose lists. This isn&#8217;t much of a problem for our little grammar, but it certainly would be if we were working with a more realistic grammar capable of generating a large number of sentences. We need to do something about this. 
</p> 
<!--l. 358--> 
<p class="noindent"> 
</p> 
<h4 class="likesubsectionHead"> 
<a id="x45-640007.1"> 
</a> CFG recognition using difference lists 
</h4> 
<!--l. 362--> 
<p class="noindent"> A more efficient implementation can be obtained by making use of 
<span class="cmti-10"> difference lists 
</span> . This is a sophisticated (and, once you&#8217;ve grasped it, beautiful) Prolog technique that can be used for a variety of purposes. 
</p> 
<!--l. 368--> 
<p class="indent"> The key idea underlying difference lists is to represent the information about grammatical categories not as a single list, but as the difference between two lists. For example, instead of representing 
<span class="cmti-10"> a woman shoots a man 
</span> as 
<span class="verb"> 
<span class="cmtt-10"> [a,woman,shoots,a,man] 
</span> 
</span> we can represent it as the pair of lists 
</p> 
<div class="fancyvrb" id="fancyvrb314"> 
<a id="x45-64002r1"> 
</a> 
<span class="cmtt-10"> [a,woman,shoots,a,man] 
</span> 
<span class="cmtt-10"> &#x00A0;[]. 
</span> 
</div> 
<!--l. 376--> 
<p class="noindent"> Think of the first list as 
<span class="cmti-10"> what needs to be consumed 
</span> (or if you prefer: the 
<span class="cmti-10"> input list 
</span> ), and the second list as 
<span class="cmti-10"> what we should leave behind 
</span> (or: the 
<span class="cmti-10"> output list 
</span> ). Viewed from this (rather procedural) perspective the difference list 
</p> 
<div class="fancyvrb" id="fancyvrb315"> 
<a id="x45-64004r1"> 
</a> 
<span class="cmtt-10"> [a,woman,shoots,a,man] 
</span> 
<span class="cmtt-10"> &#x00A0;[]. 
</span> 
</div> 
<!--l. 384--> 
<p class="noindent"> represents the sentence 
<span class="cmti-10"> a woman shoots a man 
</span> because it says: 
<span class="cmti-10"> If I consume all the 
</span> 
<span class="cmti-10"> symbols on the left, and leave behind the symbols on the right, then I have the 
</span> 
<span class="cmti-10"> sentence I am interested in. 
</span> That is, the sentence we are interested in is the difference between the contents of these two lists. 
</p> 
<!--l. 394--> 
<p class="indent"> That&#8217;s all we need to know about difference lists to rewrite our recogniser. If we simply bear in mind the idea of consuming something, and leaving something behind in mind, we obtain the following recogniser: 
</p> 
<div class="fancyvrb" id="fancyvrb316"> 
<a id="x45-64006r1"> 
</a> 
<span class="cmtt-10"> s(X,Z):- 
</span> 
<span class="cmtt-10"> &#x00A0;np(X,Y), 
</span> 
<span class="cmtt-10"> &#x00A0;vp(Y,Z). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-64008r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-64010r3"> 
</a> 
<span class="cmtt-10"> np(X,Z):- 
</span> 
<span class="cmtt-10"> &#x00A0;det(X,Y), 
</span> 
<span class="cmtt-10"> &#x00A0;n(Y,Z). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-64012r4"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-64014r5"> 
</a> 
<span class="cmtt-10"> vp(X,Z):- 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;v(X,Y), 
</span> 
<span class="cmtt-10"> &#x00A0;np(Y,Z). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-64016r6"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-64018r7"> 
</a> 
<span class="cmtt-10"> vp(X,Z):- 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;v(X,Z). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-64020r8"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-64022r9"> 
</a> 
<span class="cmtt-10"> det([the|W],W). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-64024r10"> 
</a> 
<span class="cmtt-10"> det([a|W],W). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-64026r11"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-64028r12"> 
</a> 
<span class="cmtt-10"> n([woman|W],W). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-64030r13"> 
</a> 
<span class="cmtt-10"> n([man|W],W). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-64032r14"> 
</a> 
<br class="fancyvrb" /> 
<a id="x45-64034r15"> 
</a> 
<span class="cmtt-10"> v([shoots|W],W). 
</span> 
</div> 
<!--l. 416--> 
<p class="indent"> Consider these rules carefully. For example, the 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
</span> rule says: 
<span class="cmti-10"> I know that the pair of 
</span> 
<span class="cmti-10"> lists 
</span> 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> 
<span class="cmti-10"> and 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> 
<span class="cmti-10"> represents a sentence if (1) I can consume 
</span> 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> 
<span class="cmti-10"> and leave behind a 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> , 
<span class="cmti-10"> and 
</span> 
<span class="cmti-10"> the pair 
</span> 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> 
<span class="cmti-10"> and 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> 
<span class="cmti-10"> represents a noun phrase, and (2) I can then go on to consume 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> 
<span class="cmti-10"> leaving Z behind 
</span> , 
<span class="cmti-10"> and the pair 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Y 
</span> 
</span> 
<span class="verb"> 
<span class="cmtt-10"> Z 
</span> 
</span> 
<span class="cmti-10"> represents a verb phrase 
</span> . The 
<span class="verb"> 
<span class="cmtt-10"> np 
</span> 
</span> rule and the second of the 
<span class="verb"> 
<span class="cmtt-10"> vp 
</span> 
</span> rules work similarly. 
</p> 
<!--l. 425--> 
<p class="indent"> Moreover, the same idea underlies the way this grammar handles the words. For example 
</p> 
<div class="fancyvrb" id="fancyvrb317"> 
<a id="x45-64036r1"> 
</a> 
<span class="cmtt-10"> n([man|W],W). 
</span> 
</div> 
<!--l. 430--> 
<p class="noindent"> means we are handling 
<span class="cmti-10"> man 
</span> as the difference between 
<span class="verb"> 
<span class="cmtt-10"> [man|W] 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> W 
</span> 
</span> . After all, the difference between what is consumed and what is left behind is precisely the word 
<span class="verb"> 
<span class="cmtt-10"> man 
</span> 
</span> . 
</p> 
<!--l. 434--> 
<p class="indent"> Now, at first this code may be harder to grasp than our previous recogniser. But note that we have gained something important: 
<span class="cmti-10"> we haven&#8217;t used 
</span> 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> . In the difference list based recogniser, it simply isn&#8217;t needed, and this makes a big difference. 
</p> 
<!--l. 439--> 
<p class="indent"> How do we use this recogniser? Well, here&#8217;s how to recognise sentences: 
</p> 
<div class="fancyvrb" id="fancyvrb318"> 
<a id="x45-64038r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;s([a,woman,shoots,a,man],[]). 
</span> 
<br class="fancyvrb" /> 
<a id="x45-64040r2"> 
</a> 
<span class="cmtt-10"> yes 
</span> 
</div> 
<!--l. 445--> 
<p class="noindent"> This asks whether we can get an 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
</span> by consuming the symbols in 
<span class="verb"> 
<span class="cmtt-10"> [a,woman,shoots,a,man] 
</span> 
</span> , leaving nothing behind. Similarly, to generate all the sentences in the grammar, we ask 
</p> 
<div class="fancyvrb" id="fancyvrb319"> 
<a id="x45-64042r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;s(X,[]). 
</span> 
</div> 
<!--l. 452--> 
<p class="noindent"> This asks: what values can you give to 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> , such that we get an 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
</span> by consuming the symbols in 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
</span> , leaving nothing behind? 
</p> 
<!--l. 455--> 
<p class="indent"> The queries for other grammatical categories also work the same way. For example, to find out if 
<span class="cmti-10"> a woman 
</span> is a noun phrase we ask: 
</p> 
<div class="fancyvrb" id="fancyvrb320"> 
<a id="x45-64044r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;np([a,woman],[]). 
</span> 
</div> 
<!--l. 460--> 
<p class="noindent"> And we generate all the noun phrases in the grammar as follows: 
</p> 
<div class="fancyvrb" id="fancyvrb321"> 
<a id="x45-64046r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;np(X,[]). 
</span> 
</div> 
<!--l. 466--> 
<p class="indent"> You should trace what happens when this program analyses a sentence such as 
<span class="cmti-10"> a 
</span> 
<span class="cmti-10"> woman shoots a man 
</span> . As you will see, it is a lot more efficient than our 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> based program. Moreover, as no use is made of 
<span class="verb"> 
<span class="cmtt-10"> append/3 
</span> 
</span> , the trace is a lot easier to grasp. So we have taken a big step forward. 
</p> 
<!--l. 472--> 
<p class="indent"> On the other hand, it has to be admitted that the second recogniser is not as easy to understand, at least at first, and it&#8217;s a pain having to keep track of all those difference list variables. If only it were possible to have a recogniser as simple as the first and as efficient as the second. And in fact, it 
<span class="cmti-10"> is 
</span> possible: this is where DCGs come in. 
</p> 
<!--l. 481--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse34"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse28"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlch8"> up 
</a> ] 
</p> 
</div> 
<!--l. 481--> 
<p class="indent"> 
<a id="taillpn-htmlse28"> 
</a> 
</p> 