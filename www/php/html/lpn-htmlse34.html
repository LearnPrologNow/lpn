
<!--l. 760--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse41"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse33"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse33"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse29"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlch9"> up 
</a> ] 
</p> 
</div> 
<h3 class="sectionHead"> 
<span class="titlemark"> 8.3 
</span> 
<a id="x54-780008.3"> 
</a> Concluding Remarks 
</h3> 
<!--l. 764--> 
<p class="noindent"> We now have a fairly useful picture of what DCGs are and what they can do for us. To conclude, let&#8217;s think about them from a somewhat higher level, from both a formal and a linguistic perspective. 
</p> 
<!--l. 768--> 
<p class="indent"> First the formal remarks. For the most part, we have presented DCGs as a simple tool for encoding context free grammars (or context free grammars enriched with features such as 
<span class="cmti-10"> subject 
</span> and 
<span class="cmti-10"> object 
</span> ). But DCGs go beyond this. We saw that it was possible to write a DCG that generated a language that was not context free. In fact, 
<span class="cmti-10"> any program whatsoever 
</span> can be written in DCG notation. That is, DCGs are a full-fledged programming language in their own right (they are Turing-complete, to use the proper terminology). And although DCGs are usually associated with linguistic applications, they can be useful for other purposes. 
</p> 
<!--l. 779--> 
<p class="indent"> How good are DCGs from a linguistic perspective? Well, mixed. At one stage (in the early 1980s) they were pretty much state of the art. They made it possible to code complex grammars in a clear way, and to explore the interplay of syntactic and semantic ideas. Certainly any history of parsing in computational linguistics would give DCGs an honourable mention. 
</p> 
<!--l. 786--> 
<p class="indent"> Nonetheless, DCGs have drawbacks. For a start, their tendency to loop when the goal ordering is wrong (we saw an example in the previous chapter when we added a left-recursive rule for conjunctions) is annoying; we 
<span class="cmti-10"> don&#8217;t 
</span> want to think about such issues when writing serious grammars. Furthermore, while the ability to add extra arguments is useful, if we need to use lots of them (and for big grammars we will) it is a rather clumsy mechanism. 
</p> 
<!--l. 794--> 
<p class="indent"> It is important to notice, however, that these problems come up because of the way Prolog interprets DCG rules. They are not inherent to the DCG notation. Any of you who have studied parsing algorithms probably know that all top-down parsers loop on left-recursive grammars. So, it is not surprising that Prolog, which interprets DCGs in a top-down fashion, loops on the left-recursive grammar rule 
<span class="verb"> 
<span class="cmtt-10"> s 
</span> 
<span class="cmtt-10"> &#x00A0;--&#x003E; 
</span> 
<span class="cmtt-10"> &#x00A0;s 
</span> 
<span class="cmtt-10"> &#x00A0;conj 
</span> 
<span class="cmtt-10"> &#x00A0;s 
</span> 
</span> . If we used a different strategy to interpret DCGs, for example a bottom-up strategy, we would not run into the same problem. Similarly, if we didn&#8217;t use Prolog&#8217;s built-in interpretation of DCGs, we could use the extra arguments for a more sophisticated specification of features, one that would facilitate the use of large feature structures. 
</p> 
<!--l. 807--> 
<p class="indent"> Summing up, nowadays DCGs are probably best viewed as a nice notation for defining context free grammars enhanced with some features, a notation that (ignoring left-recursion) doubles as a parser/recogniser. That is, they are best viewed as a convenient tool for testing new grammatical ideas, or for implementing reasonably complex grammars for particular applications. DCGs are no longer state of the art, but they are useful. Even if you have never programmed before, simply by using what you have learned so far you are ready to start experimenting with reasonably sophisticated grammar writing. With a conventional programming language (such as C++ or Java) it simply wouldn&#8217;t be possible to reach this stage so soon. Things would be easier in functional languages (such as Lisp, Caml, or Haskell), but even so, it is doubtful whether beginners could do so much so early. 
</p> 
<!--l. 822--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse41"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse33"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse33"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse34"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlch9"> up 
</a> ] 
</p> 
</div> 
<!--l. 822--> 
<p class="indent"> 
<a id="taillpn-htmlse34"> 
</a> 
</p> 