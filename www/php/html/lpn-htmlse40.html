
<!--l. 742--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse47"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse39"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse39"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse34"> tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlch10"> up 
</a> ] 
</p> 
</div> 
<h3 class="sectionHead"> 
<span class="titlemark"> 9.4 
</span> 
<a id="x61-900009.4"> 
</a> Operators 
</h3> 
<!--l. 745--> 
<p class="noindent"> As we have seen, in certain cases (for example, when performing arithmetic) Prolog lets us use operator notations that are more user-friendly than its own internal representations. Indeed, as we shall now see, Prolog even has a mechanism for letting us define our own operators. In this section we&#8217;ll first take a closer look at the properties of operators, and then learn how to define our own. 
</p> 
<!--l. 753--> 
<p class="noindent"> 
</p> 
<h4 class="likesubsectionHead"> 
<a id="x61-910009.4"> 
</a> Properties of operators 
</h4> 
<!--l. 756--> 
<p class="noindent"> Let&#8217;s start with an example from arithmetic. Internally, Prolog uses the expression 
<span class="verb"> 
<span class="cmtt-10"> is(11,+(2,*(3,3))) 
</span> 
</span> , but we are free to write the functors 
<span class="verb"> 
<span class="cmtt-10"> * 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> between their arguments, to form the more user-friendly expression 
<span class="verb"> 
<span class="cmtt-10"> 11 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;2 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;* 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
</span> . Functors that can be written between their arguments are called infix operators. Other examples of infix operators in Prolog are 
<span class="verb"> 
<span class="cmtt-10"> :- 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> --&#x003E; 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> ; 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> &#8217;,&#8217; 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> = 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> =.. 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> == 
</span> 
</span> and so on. In addition to infix operators there are also prefix operators (which are written before their arguments) and postfix operators (which are written after). For example, 
<span class="verb"> 
<span class="cmtt-10"> ?- 
</span> 
</span> is a prefix operator, and so is the one-place 
<span class="verb"> 
<span class="cmtt-10"> - 
</span> 
</span> which is used to represent negative numbers (as in 
<span class="verb"> 
<span class="cmtt-10"> 1 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;-2 
</span> 
</span> ). An example of a postfix operator is the 
<span class="verb"> 
<span class="cmtt-10"> ++ 
</span> 
</span> notation used in the C programming language to increment the value of a variable. 
</p> 
<!--l. 771--> 
<p class="indent"> When we learned about arithmetic in Prolog, we saw that Prolog knows about the conventions for disambiguating arithmetic expressions. So when we write 
<span class="verb"> 
<span class="cmtt-10"> 2 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;* 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
</span> , Prolog knows that we mean 
<span class="verb"> 
<span class="cmtt-10"> 2 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;(3 
</span> 
<span class="cmtt-10"> &#x00A0;* 
</span> 
<span class="cmtt-10"> &#x00A0;3) 
</span> 
</span> and not 
<span class="verb"> 
<span class="cmtt-10"> (2 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;3) 
</span> 
<span class="cmtt-10"> &#x00A0;* 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
</span> . But how does Prolog know this? Because every operator has a certain precedence. The precedence of 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> is greater than the precedence of 
<span class="verb"> 
<span class="cmtt-10"> * 
</span> 
</span> , and that&#8217;s why 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> is taken to be the main functor of the expression 
<span class="verb"> 
<span class="cmtt-10"> 2 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;* 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
</span> . (Note that Prolog&#8217;s internal representation 
<span class="verb"> 
<span class="cmtt-10"> +(2,*(3,3)) 
</span> 
</span> is not ambiguous.) Similarly, the precedence of 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> is higher than the precedence of 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> , so 
<span class="verb"> 
<span class="cmtt-10"> 11 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;2 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;* 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
</span> is interpreted as 
<span class="verb"> 
<span class="cmtt-10"> is(11,+(2,*(3,3))) 
</span> 
</span> and not as the (nonsensical) expression 
<span class="verb"> 
<span class="cmtt-10"> +(is(11,2),*(3,3)) 
</span> 
</span> . In Prolog, precedence is expressed by a number between 0 and 1200; the higher the number, the greater the precedence. To give some examples, the precedence of 
<span class="verb"> 
<span class="cmtt-10"> = 
</span> 
</span> is 700, the precedence of 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> is 500, and the precedence of 
<span class="verb"> 
<span class="cmtt-10"> * 
</span> 
</span> is 400. 
</p> 
<!--l. 788--> 
<p class="indent"> What happens when there are several operators with the same precedence in one expression? We said above that Prolog finds the query 
<span class="verb"> 
<span class="cmtt-10"> 2 
</span> 
<span class="cmtt-10"> &#x00A0;=:= 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;== 
</span> 
<span class="cmtt-10"> &#x00A0;=:=(2,3) 
</span> 
</span> confusing. It doesn&#8217;t know how to bracket the expression: Is it 
<span class="verb"> 
<span class="cmtt-10"> =:=(2,==(3,=:=(2,3))) 
</span> 
</span> or is it 
<span class="verb"> 
<span class="cmtt-10"> ==(=:=(2,3),=:=(2,3)) 
</span> 
</span> ? The reason Prolog is not able to decide on the correct bracketing is because 
<span class="verb"> 
<span class="cmtt-10"> == 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> =:= 
</span> 
</span> have the same precedence. In such cases, explicit bracketings must be supplied by the programmer. 
</p> 
<!--l. 797--> 
<p class="indent"> What about the following query though? 
</p> 
<div class="fancyvrb" id="fancyvrb420"> 
<a id="x61-91002r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;X 
</span> 
<span class="cmtt-10"> &#x00A0;is 
</span> 
<span class="cmtt-10"> &#x00A0;2 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;4. 
</span> 
</div> 
<!--l. 801--> 
<p class="noindent"> Does Prolog find this confusing? Not at all: it deals with it happily and correctly answers 
<span class="verb"> 
<span class="cmtt-10"> X 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;9 
</span> 
</span> . But which bracketing did Prolog choose: 
<span class="verb"> 
<span class="cmtt-10"> is(X,+(2,+(3,4))) 
</span> 
</span> or 
<span class="verb"> 
<span class="cmtt-10"> is(X,+(+(2,3),4)) 
</span> 
</span> ? As the following queries show, it chose the second: 
</p> 
<!--l. 806--> 
<p class="indent"> 
</p> 
<div class="fancyvrb" id="fancyvrb421"> 
<a id="x61-91004r1"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;2 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;4 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;+(2,+(3,4)). 
</span> 
<br class="fancyvrb" /> 
<a id="x61-91006r2"> 
</a> 
<span class="cmtt-10"> no 
</span> 
<br class="fancyvrb" /> 
<a id="x61-91008r3"> 
</a> 
<span class="cmtt-10"> ?- 
</span> 
<span class="cmtt-10"> &#x00A0;2 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;4 
</span> 
<span class="cmtt-10"> &#x00A0;= 
</span> 
<span class="cmtt-10"> &#x00A0;+(+(2,3),4). 
</span> 
<br class="fancyvrb" /> 
<a id="x61-91010r4"> 
</a> 
<span class="cmtt-10"> yes 
</span> 
</div> 
<!--l. 814--> 
<p class="indent"> Here Prolog has used information about the associativity of 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> to disambiguate: 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> is left associative, which means that the expression to the right of 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> must have a lower precedence than 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> itself, whereas the expression on the left may have the same precedence as 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> . The precedence of an expression is simply the precedence of its main operator, or 0 if it is enclosed in brackets. The main operator of 
<span class="verb"> 
<span class="cmtt-10"> 3 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;4 
</span> 
</span> is 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> , so that interpreting 
<span class="verb"> 
<span class="cmtt-10"> 2 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;+ 
</span> 
<span class="cmtt-10"> &#x00A0;4 
</span> 
</span> as 
<span class="verb"> 
<span class="cmtt-10"> +(2,+(3,4)) 
</span> 
</span> would mean that the expression to the right of the first 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> has the same precedence as 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> itself, which is illegal. It has to be lower. 
</p> 
<!--l. 825--> 
<p class="indent"> The operators 
<span class="verb"> 
<span class="cmtt-10"> == 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> =:= 
</span> 
</span> , and 
<span class="verb"> 
<span class="cmtt-10"> is 
</span> 
</span> are defined to be non-associative, which means that both of their arguments must have a lower precedence. Therefore 
<span class="verb"> 
<span class="cmtt-10"> 2 
</span> 
<span class="cmtt-10"> &#x00A0;=:= 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
<span class="cmtt-10"> &#x00A0;== 
</span> 
<span class="cmtt-10"> &#x00A0;=:=(2,3) 
</span> 
</span> is an illegal expression, since no matter how you bracket it you&#8217;ll get a conflict: 
<span class="verb"> 
<span class="cmtt-10"> 2 
</span> 
<span class="cmtt-10"> &#x00A0;=:= 
</span> 
<span class="cmtt-10"> &#x00A0;3 
</span> 
</span> has the same precedence as 
<span class="verb"> 
<span class="cmtt-10"> == 
</span> 
</span> , and 
<span class="verb"> 
<span class="cmtt-10"> 3 
</span> 
<span class="cmtt-10"> &#x00A0;== 
</span> 
<span class="cmtt-10"> &#x00A0;=:=(2,3) 
</span> 
</span> has the same precedence as 
<span class="verb"> 
<span class="cmtt-10"> =:= 
</span> 
</span> . 
</p> 
<!--l. 833--> 
<p class="indent"> The type of an operator (infix, prefix, or postfix), its precedence, and its associativity are the three things that Prolog needs to know to be able to translate user-friendly (but potentially ambiguous) operator notations into Prolog&#8217;s internal representation. 
</p> 
<!--l. 840--> 
<p class="noindent"> 
</p> 
<h4 class="likesubsectionHead"> 
<a id="x61-920009.4"> 
</a> Defining operators 
</h4> 
<!--l. 844--> 
<p class="noindent"> In addition to providing a user-friendly operator notation for certain functors, Prolog also lets you define your own operators. So you could, for example, define a postfix operator 
<span class="verb"> 
<span class="cmtt-10"> is_dead 
</span> 
</span> ; then Prolog would allow you to write 
<span class="verb"> 
<span class="cmtt-10"> zed 
</span> 
<span class="cmtt-10"> &#x00A0;is_dead 
</span> 
</span> as a fact in your database instead of 
<span class="verb"> 
<span class="cmtt-10"> is_dead(zed) 
</span> 
</span> . 
</p> 
<!--l. 850--> 
<p class="indent"> Operator definitions in Prolog look like this: 
<a id="dx61-92001"> 
</a> 
</p> 
<div class="fancyvrb" id="fancyvrb422"> 
<a id="x61-92003r1"> 
</a> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op(Precedence,Type,Name). 
</span> 
</div> 
<!--l. 854--> 
<p class="noindent"> As we mentioned above, precedence is a number between 0 and 1200, and the higher the number, the greater the precedence. Type is an atom specifying the type and associativity of the operator. In the case of 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> this atom is 
<span class="verb"> 
<span class="cmtt-10"> yfx 
</span> 
</span> , which says that 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> is an infix operator; the 
<span class="verb"> 
<span class="cmtt-10"> f 
</span> 
</span> represents the operator, and the 
<span class="verb"> 
<span class="cmtt-10"> x 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> y 
</span> 
</span> the arguments. Furthermore, 
<span class="verb"> 
<span class="cmtt-10"> x 
</span> 
</span> stands for an argument which has a precedence which is lower than the precedence of 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> and 
<span class="verb"> 
<span class="cmtt-10"> y 
</span> 
</span> stands for an argument which has a precedence which lower or equal to the precedence of 
<span class="verb"> 
<span class="cmtt-10"> + 
</span> 
</span> . There are the following possibilities for type: 
</p> 
<div class="center"> 
<!--l. 865--> 
<p class="noindent"> 
</p> 
<div class="tabular"> 
<table id="TBL-11" class="tabular" cellspacing="0" cellpadding="0"> 
<colgroup id="TBL-11-1g"> 
<col id="TBL-11-1" /> 
<col id="TBL-11-2" /> 
</colgroup> 
<tr style="vertical-align:baseline;" id="TBL-11-1-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-11-1-1" class="td11"> infix 
</td> 
<td style="white-space:nowrap; text-align:left;" id="TBL-11-1-2" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> xfx 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> xfy 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> yfx 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-11-2-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-11-2-1" class="td11"> prefix 
</td> 
<td style="white-space:nowrap; text-align:left;" id="TBL-11-2-2" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> fx 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> fy 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-11-3-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-11-3-1" class="td11"> suffix 
</td> 
<td style="white-space:nowrap; text-align:left;" id="TBL-11-3-2" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> xf 
</span> 
</span> , 
<span class="verb"> 
<span class="cmtt-10"> yf 
</span> 
</span> 
</td> 
</tr> 
</table> 
</div> 
</div> 
<!--l. 871--> 
<p class="indent"> So your operator definition for 
<span class="verb"> 
<span class="cmtt-10"> is_dead 
</span> 
</span> might be as follows: 
</p> 
<div class="fancyvrb" id="fancyvrb423"> 
<a id="x61-92005r1"> 
</a> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op(500, 
</span> 
<span class="cmtt-10"> &#x00A0;xf, 
</span> 
<span class="cmtt-10"> &#x00A0;is_dead). 
</span> 
</div> 
<!--l. 877--> 
<p class="indent"> Here are the definitions for some of the built-in operators. You can see that operators with the same properties can be specified in one statement by giving a list of their names (instead of a single name) as the third argument of 
<span class="verb"> 
<span class="cmtt-10"> op 
</span> 
</span> . 
</p> 
<div class="center"> 
<!--l. 882--> 
<p class="noindent"> 
</p> 
<div class="tabular"> 
<table id="TBL-12" class="tabular" cellspacing="0" cellpadding="0"> 
<colgroup id="TBL-12-1g"> 
<col id="TBL-12-1" /> 
</colgroup> 
<tr style="vertical-align:baseline;" id="TBL-12-1-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-12-1-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op( 
</span> 
<span class="cmtt-10"> &#x00A0;1200, 
</span> 
<span class="cmtt-10"> &#x00A0;xfx, 
</span> 
<span class="cmtt-10"> &#x00A0;[ 
</span> 
<span class="cmtt-10"> &#x00A0;:-, 
</span> 
<span class="cmtt-10"> &#x00A0;--&#x003E; 
</span> 
<span class="cmtt-10"> &#x00A0;]). 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-12-2-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-12-2-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op( 
</span> 
<span class="cmtt-10"> &#x00A0;1200, 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;fx, 
</span> 
<span class="cmtt-10"> &#x00A0;[ 
</span> 
<span class="cmtt-10"> &#x00A0;:-, 
</span> 
<span class="cmtt-10"> &#x00A0;?- 
</span> 
<span class="cmtt-10"> &#x00A0;]). 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-12-3-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-12-3-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op( 
</span> 
<span class="cmtt-10"> &#x00A0;1100, 
</span> 
<span class="cmtt-10"> &#x00A0;xfy, 
</span> 
<span class="cmtt-10"> &#x00A0;[ 
</span> 
<span class="cmtt-10"> &#x00A0;; 
</span> 
<span class="cmtt-10"> &#x00A0;]). 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-12-4-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-12-4-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op( 
</span> 
<span class="cmtt-10"> &#x00A0;1000, 
</span> 
<span class="cmtt-10"> &#x00A0;xfy, 
</span> 
<span class="cmtt-10"> &#x00A0;[ 
</span> 
<span class="cmtt-10"> &#x00A0;&#8217;,&#8217; 
</span> 
<span class="cmtt-10"> &#x00A0;]). 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-12-5-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-12-5-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op( 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;700, 
</span> 
<span class="cmtt-10"> &#x00A0;xfx, 
</span> 
<span class="cmtt-10"> &#x00A0;[ 
</span> 
<span class="cmtt-10"> &#x00A0;=, 
</span> 
<span class="cmtt-10"> &#x00A0;is, 
</span> 
<span class="cmtt-10"> &#x00A0;=.., 
</span> 
<span class="cmtt-10"> &#x00A0;==, 
</span> 
<span class="cmtt-10"> &#x00A0;\==, 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-12-6-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-12-6-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;=:=, 
</span> 
<span class="cmtt-10"> &#x00A0;=\=, 
</span> 
<span class="cmtt-10"> &#x00A0;&#x003C;, 
</span> 
<span class="cmtt-10"> &#x00A0;&#x003E;, 
</span> 
<span class="cmtt-10"> &#x00A0;=&#x003C;, 
</span> 
<span class="cmtt-10"> &#x00A0;&#x003E;= 
</span> 
<span class="cmtt-10"> &#x00A0;]). 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-12-7-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-12-7-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op( 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;500, 
</span> 
<span class="cmtt-10"> &#x00A0;yfx, 
</span> 
<span class="cmtt-10"> &#x00A0;[ 
</span> 
<span class="cmtt-10"> &#x00A0;+, 
</span> 
<span class="cmtt-10"> &#x00A0;-]). 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-12-8-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-12-8-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op( 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;500, 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;fx, 
</span> 
<span class="cmtt-10"> &#x00A0;[ 
</span> 
<span class="cmtt-10"> &#x00A0;+, 
</span> 
<span class="cmtt-10"> &#x00A0;- 
</span> 
<span class="cmtt-10"> &#x00A0;]). 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-12-9-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-12-9-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op( 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;300, 
</span> 
<span class="cmtt-10"> &#x00A0;xfx, 
</span> 
<span class="cmtt-10"> &#x00A0;[ 
</span> 
<span class="cmtt-10"> &#x00A0;mod 
</span> 
<span class="cmtt-10"> &#x00A0;]). 
</span> 
</span> 
</td> 
</tr> 
<tr style="vertical-align:baseline;" id="TBL-12-10-"> 
<td style="white-space:nowrap; text-align:left;" id="TBL-12-10-1" class="td11"> 
<span class="verb"> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op( 
</span> 
<span class="cmtt-10"> &#x00A0; 
</span> 
<span class="cmtt-10"> &#x00A0;200, 
</span> 
<span class="cmtt-10"> &#x00A0;xfy, 
</span> 
<span class="cmtt-10"> &#x00A0;[ 
</span> 
<span class="cmtt-10"> &#x00A0;^ 
</span> 
<span class="cmtt-10"> &#x00A0;]). 
</span> 
</span> 
</td> 
</tr> 
</table> 
</div> 
</div> 
<!--l. 895--> 
<p class="indent"> One final point should made explicit. Operator definitions don&#8217;t specify the 
<span class="cmti-10"> meanings 
</span> of operators, they only describe how they can be used syntactically. That is, an operator definition doesn&#8217;t say anything about when a query involving this operator will evaluate to true, it merely extends the 
<span class="cmti-10"> syntax 
</span> of Prolog. So if the operator 
<span class="verb"> 
<span class="cmtt-10"> is_dead 
</span> 
</span> is defined as above, and you pose the query 
<span class="verb"> 
<span class="cmtt-10"> zed 
</span> 
<span class="cmtt-10"> &#x00A0;is_dead 
</span> 
</span> , Prolog won&#8217;t complain about illegal syntax (as it would without this definition) but will try to prove the goal 
<span class="verb"> 
<span class="cmtt-10"> is_dead(zed) 
</span> 
</span> , which is Prolog&#8217;s internal representation of 
<span class="verb"> 
<span class="cmtt-10"> zed 
</span> 
<span class="cmtt-10"> &#x00A0;is_dead 
</span> 
</span> . And this is all operator definitions do &#8212; they just tell Prolog how to translate a user-friendly notation into real Prolog notation. So, what would be Prolog&#8217;s answer to the query 
<span class="verb"> 
<span class="cmtt-10"> zed 
</span> 
<span class="cmtt-10"> &#x00A0;is_dead 
</span> 
</span> ? It would be 
<span class="verb"> 
<span class="cmtt-10"> no 
</span> 
</span> , because Prolog would try to prove 
<span class="verb"> 
<span class="cmtt-10"> is_dead(zed) 
</span> 
</span> , but would not find any matching clause in the database. But suppose we extended the database as follows: 
</p> 
<div class="fancyvrb" id="fancyvrb424"> 
<a id="x61-92007r1"> 
</a> 
<span class="cmtt-10"> :- 
</span> 
<span class="cmtt-10"> &#x00A0;op(500, 
</span> 
<span class="cmtt-10"> &#x00A0;xf, 
</span> 
<span class="cmtt-10"> &#x00A0;is_dead). 
</span> 
<br class="fancyvrb" /> 
<a id="x61-92009r2"> 
</a> 
<br class="fancyvrb" /> 
<a id="x61-92011r3"> 
</a> 
<span class="cmtt-10"> kill(marsellus,zed). 
</span> 
<br class="fancyvrb" /> 
<a id="x61-92013r4"> 
</a> 
<span class="cmtt-10"> is_dead(X) 
</span> 
<span class="cmtt-10"> &#x00A0;:- 
</span> 
<span class="cmtt-10"> &#x00A0;kill(_,X). 
</span> 
</div> 
<!--l. 916--> 
<p class="noindent"> Now Prolog would answer 
<span class="verb"> 
<span class="cmtt-10"> yes 
</span> 
</span> to the query. 
</p> 
<!--l. 919--> 
<div class="crosslinks"> 
<p class="noindent"> [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse47"> next 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse39"> prev 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse39"> prev-tail 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlse40"> front 
</a> ] [ 
<a href="lpnpage.php?pagetype=html&pageid=lpn-htmlch10"> up 
</a> ] 
</p> 
</div> 
<!--l. 919--> 
<p class="indent"> 
<a id="taillpn-htmlse40"> 
</a> 
</p> 