
\chapter*{Introduction}\label{INTRODUCTION}

First off, what is Prolog? It's a programming language, but a rather
unusual one. ``Prolog'' is short for ``Programming with Logic'', and
though the link between logic and Prolog is not completely
straightforward, it is this link that gives Prolog its special
character.  At the heart of Prolog lies a beautiful idea: don't tell
the computer what to do, simply describe situations of interest. Where
does the computation come in? When we ask questions.  Prolog enables
the computer to logically deduce new facts about the situations we
describe, and gives its deductions back to us as answers.

This has a number of consequences. First, a practical one: if you are
an experienced programmer, Prolog is likely to take you by
surprise. It requires a different mindset.  You have to learn to see
computational problems from a different perspective.  To use the
standard terminology, you have to learn to think
\textit{declaratively}, rather than \textit{procedurally}.  This can
be challenging, but it's also a lot of fun.

A second consequence of Prolog's ``say what the problem \textit{is},
rather than how to solve it'' stance is that Prolog is a very 
high-level language. As will become apparent, Prolog enables you to
describe some highly abstract things (for example, the syntactic
structure of English) extremely succinctly. Moreover, these
descriptions really are programs: they will do real work for us if we
ask the right questions. For example, having described the syntactic
structure of English, we can ask Prolog whether particular sentences
are grammatical or not. Prolog will tell us, and if we ask the right
question, will even give us a grammatical analysis.

Prolog's ability to describe complex situations succinctly means that
it is good for rapid prototyping.  That is, if you have a good idea,
and want to get a working program that embodies it, Prolog is often an
excellent choice. Ideas become computational reality fast with Prolog,
at least for some applications.  Which applications?  Those which
depend on getting to grips with rich structure.  Prolog application
areas include computational linguistics (or natural languages
processing as it is often called), Artificial Intelligence (AI),
expert systems, molecular biology, and the semantic web. Where there
is structure to be described, or knowledge to be represented, Prolog
is likely to come into its own.

Prolog is not a perfect language, and it's not suitable for
everything.  If you need to do serious text manipulation, go for Perl.
If you need tight control over memory, go for C. If you want a
mathematically elegant language that you can reason about easily, go
for Caml, Haskell, or a clean Lisp dialect (such as Scheme).  But no
language is good for everything, and those that try (remember Ada?)
often fall by the wayside. As we have just said, Prolog is a natural
choice for knowledge-rich tasks, and there are a number of good
reasons for learning it. If you are an experienced programmer, we
think you will enjoy learning Prolog simply because it is so
different; thinking declaratively, or almost declaratively, can send
your brain in interesting new directions.  And if you have little or
no programing experience, and maybe aren't even sure if you like
computers or not, then there are excellent reasons for choosing Prolog
as your first language. Because it is so high-level, you
get to do interesting things fast, without getting bogged down in
tedious preparatory work. Moreover, you will swiftly learn about a
number of fundamental programming concepts, notably recursion and
recursive data structures, concepts that will be useful if you later
study other languages. Finally, the link with logic adds an intriguing
intellectual dimension to the learning process.

Where does Prolog come from? It originated in Marseilles, in the south
of France. Alain Colmerauer and Philippe Roussel devised and
implemented the first Prolog interpreter in 1972.  One of the earliest
versions was partially implemented in Fortran, and partially in Prolog
itself. An interesting mixture: it would be hard to find two languages
that differ more widely than the numerically oriented, non-recursive,
imperative scientific programming language Fortran, and the
symbolically oriented, recursive, declarative Prolog.  A few
years later, Robert Kowalski, who had worked with the Marseilles team
in 1971 and 1972, published his book \textit{Logic for Problem
Solving}%
\footnote{\textit{Logic for Problem Solving}, R. Kowalski,
Elsevier/North-Holland, 1979.}  which put the idea of logic
programming firmly on the intellectual agenda.  Another big step was
taken in Edinburgh in 1977 with  David Warren's implementation of
the DEC 10 compiler.%
\footnote{David H. D. Warren, \textit{Applied Logic --- Its Use and
Implementation as a Programming Tool}, PhD thesis, University of
Edinburgh. Scotland, 1977.} This implementation, which could compete
with (and sometimes surpass) state of the art Lisp implementations in
terms of efficiency, turned Prolog from an academic curiosity into a
serious programming language.  Interesting work soon followed. For
example, in a classic paper, Pereira and Warren showed that Prolog's
built-in mechanism for handling Definite Clause Grammars (DCGs) was a
natural way of treating certain tasks in natural language processing.%
\footnote{
``Definite clause grammars for language
analysis --- a survey of the formalism and a comparison with augmented transition
networks'',  F. Pereira and D. H. D. Warren,
\textit{Journal of Artificial Intelligence}, 13(3):231--278, 1980.}

Since then, Prolog has grown in popularity, particularly in Europe and
Japan (in the United States, work on AI has tended to be Lisp-based).
Prolog is, was, and always will be, a niche language. But the niche it
occupies is fascinating.

\subsection*{How to get the most out of this book}

What we have said about Prolog so far has been high-level and
abstract. We are now going to change gears.  The approach taken to
teaching Prolog in this book is \textit{not} abstract, and is
certainly \textit{not} driven by high-level ideas (such as the link
with logic). In fact, it's resolutely down to earth. We try to teach
Prolog as concretely as possible. We've just told you why Prolog is
not just another programming language, but we're going to teach it as
if it was.

Why? Quite simply, because we think that's the best approach for a
first course.  Programming in Prolog is a practical skill. There are
concrete things that simply have to be learned, and we strongly
believe that you just have to get in there and learn them as fast as
possible. This does not mean that we find the abstract side of Prolog
(and more generally, logic programming) unimportant or
uninteresting. However (unless you already have a good theoretical
background) these deeper ideas take time to emerge clearly and be
absorbed. In the meantime, you should be getting on with mastering the
nuts and bolts.

To put it another way, we think that learning a programming language
(any programming language, not just Prolog) is a lot like learning a
foreign language. And what is the most important part of learning a
foreign language? Actually \textit{using} it, actually putting it to
work, actually trying it out. Sure, reflecting on the beauty of the
language is pleasant, but at the end of the day, what really counts is
the time you spend on mastering the mechanics.

This attitude has strongly influenced the way \textit{Learn Prolog
  Now!}  is written. In particular, as you will see, each chapter is
  divided into three parts. First comes the text. Next come a number
  of exercises. Finally there is what we call the practical session.
  Now, we cannot emphasise the following point too strongly:
  \textit{the practical sessions are the most important part of the
  book}.  It is utterly imperative that you sit down, fire up a Prolog
  interpreter, and work through these sessions. Actually, just doing
  that is nowhere near enough. If you really want to master Prolog,
  you need to try out a lot more than is asked of you in these
  sessions. But we believe these sessions contain enough to put you on
  the right track.

Gaining practical experience with a programming language is always
important, but, in our opinion, it is even more important than usual
with Prolog. Why?  Because Prolog is deceptively easy to
understand. It's a small language (there are not a lot of constructs
to learn) and the basic ideas are beautiful in their simplicity. It is
dangerously easy to smile, relax, and say ```Hey! I get it!''.  Easy,
but wrong. The basic ideas interact in subtle ways, and without
\textit{lots} of practical experience you will be lost. We have had
many (very bright) students who thought they understood it, didn't put
in the effort on the practical side --- and who later found themselves
scrambling to keep up.  Prolog is subtle. You need to put in the hours
if you want to master it.

\medskip

Summing up, \textit{Learn Prolog Now} is a practically oriented
introduction to the central features of Prolog. It won't teach you
everything, but if you make it to the end you'll have a good grasp of
the basics, and will have caught a glimpse of what logic programming is
about. Enjoy!

